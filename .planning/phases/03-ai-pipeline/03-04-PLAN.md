---
phase: 03-ai-pipeline
plan: 04
type: execute
wave: 3
depends_on: ["03-01"]
files_modified:
  - src/components/processing/ProcessingScreen.tsx
  - src/components/processing/StepIndicator.tsx
  - src/components/processing/GeometricAnimation.tsx
  - src/components/processing/ErrorFallback.tsx
autonomous: true

must_haves:
  truths:
    - "User sees animated step progress during processing"
    - "Steps display: Analyzing -> Measuring -> Styling -> Creating"
    - "Completed steps show checkmarks"
    - "Current step shows spinner animation"
    - "Abstract geometric animation plays during processing"
    - "Error state shows retry option"
  artifacts:
    - path: "src/components/processing/ProcessingScreen.tsx"
      provides: "Main processing container"
      exports: ["ProcessingScreen"]
    - path: "src/components/processing/StepIndicator.tsx"
      provides: "Animated step progress"
      exports: ["StepIndicator"]
    - path: "src/components/processing/GeometricAnimation.tsx"
      provides: "Abstract motion graphics"
      exports: ["GeometricAnimation"]
    - path: "src/components/processing/ErrorFallback.tsx"
      provides: "Retry UI"
      exports: ["ErrorFallback"]
  key_links:
    - from: "src/components/processing/ProcessingScreen.tsx"
      to: "src/components/processing/StepIndicator.tsx"
      via: "component composition"
      pattern: "StepIndicator"
    - from: "src/components/processing/StepIndicator.tsx"
      to: "framer-motion"
      via: "animation library"
      pattern: "import.*framer-motion"
    - from: "src/components/processing/StepIndicator.tsx"
      to: "src/types/ai-pipeline.ts"
      via: "PipelineStage type"
      pattern: "PipelineStage"
      note: "Stage names (analyzing/measuring/styling/creating) are contractual from CONTEXT.md locked decisions"
---

<objective>
Build the processing UI components showing animated progress through AI pipeline stages.

Purpose: Provide visual feedback during the ~30 second processing time, keeping users engaged and informed.
Output: Full-screen processing screen with step indicators, geometric animation, and error handling.

**Note on Stage Names:**
Stage names (Analyzing -> Measuring -> Styling -> Creating) are locked decisions from CONTEXT.md.
These are contractual UI labels, not code dependencies. The StepIndicator component maps these labels
to PipelineStage type values which are used throughout the pipeline orchestration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-ai-pipeline/03-CONTEXT.md
@.planning/phases/03-ai-pipeline/03-RESEARCH.md
@.planning/phases/03-ai-pipeline/03-01-SUMMARY.md
@src/types/ai-pipeline.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Step Indicator Component</name>
  <files>src/components/processing/StepIndicator.tsx</files>
  <action>
Create animated step indicator following CONTEXT.md decisions:
- Named stages: Analyzing -> Measuring -> Styling -> Creating (LOCKED from CONTEXT.md)
- Checkmarks for completed steps
- No time estimates shown

```typescript
'use client';

import { motion } from 'framer-motion';
import { Check, Loader2 } from 'lucide-react';
import { PipelineStage } from '@/types/ai-pipeline';

/**
 * Stage configuration - labels are contractual from CONTEXT.md locked decisions
 * These must match the PipelineStage type values in src/types/ai-pipeline.ts
 */
const STAGES: { id: PipelineStage; label: string }[] = [
  { id: 'analyzing', label: 'Analyzing' },
  { id: 'measuring', label: 'Measuring' },
  { id: 'styling', label: 'Styling' },
  { id: 'creating', label: 'Creating' },
];

interface StepIndicatorProps {
  currentStage: PipelineStage;
  completedStages: PipelineStage[];
}

export function StepIndicator({ currentStage, completedStages }: StepIndicatorProps) {
  const currentIndex = STAGES.findIndex((s) => s.id === currentStage);

  return (
    <div className="flex justify-between items-center max-w-sm mx-auto px-4">
      {STAGES.map((stage, index) => {
        const isComplete = completedStages.includes(stage.id);
        const isCurrent = stage.id === currentStage;
        const isPending = !isComplete && !isCurrent;

        return (
          <div key={stage.id} className="flex flex-col items-center flex-1">
            {/* Connector line (except for first item) */}
            {index > 0 && (
              <div className="absolute h-0.5 w-full -z-10">
                <motion.div
                  className="h-full bg-emerald-500"
                  initial={{ width: '0%' }}
                  animate={{
                    width: index <= currentIndex ? '100%' : '0%',
                  }}
                  transition={{ duration: 0.3, delay: 0.1 }}
                />
              </div>
            )}

            {/* Step circle */}
            <motion.div
              className="w-10 h-10 rounded-full flex items-center justify-center border-2"
              animate={{
                backgroundColor: isComplete
                  ? '#10b981' // emerald-500
                  : isCurrent
                    ? '#3b82f6' // blue-500
                    : 'transparent',
                borderColor: isComplete
                  ? '#10b981'
                  : isCurrent
                    ? '#3b82f6'
                    : '#6b7280', // gray-500
                scale: isCurrent ? 1.1 : 1,
              }}
              transition={{ duration: 0.3 }}
            >
              {isComplete && (
                <motion.div
                  initial={{ scale: 0 }}
                  animate={{ scale: 1 }}
                  transition={{ type: 'spring', stiffness: 500, damping: 30 }}
                >
                  <Check className="w-5 h-5 text-white" />
                </motion.div>
              )}
              {isCurrent && (
                <Loader2 className="w-5 h-5 text-white animate-spin" />
              )}
              {isPending && (
                <span className="text-sm text-gray-500 font-medium">
                  {index + 1}
                </span>
              )}
            </motion.div>

            {/* Label */}
            <motion.span
              className="text-xs mt-2 font-medium"
              animate={{
                color: isComplete || isCurrent ? '#f9fafb' : '#9ca3af',
              }}
              transition={{ duration: 0.3 }}
            >
              {stage.label}
            </motion.span>
          </div>
        );
      })}
    </div>
  );
}
```

Key features:
- Spring animations for checkmark appearance
- Scale pulse on current step
- Color transitions for state changes
- No time estimates (per CONTEXT.md)
- Stage names from CONTEXT.md locked decisions
  </action>
  <verify>Component renders with all 4 stages visible</verify>
  <done>Step indicator with animated checkmarks and spinner</done>
</task>

<task type="auto">
  <name>Task 2: Create Geometric Animation Component</name>
  <files>src/components/processing/GeometricAnimation.tsx</files>
  <action>
Create abstract geometric motion animation (per CONTEXT.md: "modern, not literal"):

```typescript
'use client';

import { motion, useAnimation } from 'framer-motion';
import { useEffect } from 'react';
import { PipelineStage } from '@/types/ai-pipeline';

interface GeometricAnimationProps {
  stage: PipelineStage;
}

// Different color schemes per stage
const STAGE_COLORS: Record<PipelineStage, { from: string; to: string }> = {
  analyzing: { from: '#3b82f6', to: '#8b5cf6' },  // blue to violet
  measuring: { from: '#8b5cf6', to: '#ec4899' },  // violet to pink
  styling: { from: '#ec4899', to: '#f59e0b' },    // pink to amber
  creating: { from: '#f59e0b', to: '#10b981' },   // amber to emerald
};

export function GeometricAnimation({ stage }: GeometricAnimationProps) {
  const controls = useAnimation();
  const colors = STAGE_COLORS[stage];

  useEffect(() => {
    controls.start({
      rotate: [0, 90, 180, 270, 360],
      scale: [1, 1.15, 1, 1.15, 1],
      transition: {
        duration: 4,
        repeat: Infinity,
        ease: 'easeInOut',
      },
    });
  }, [stage, controls]);

  return (
    <div className="flex items-center justify-center h-48 relative">
      {/* Outer rotating ring */}
      <motion.div
        animate={controls}
        className="absolute w-32 h-32 rounded-full border-4 border-dashed"
        style={{ borderColor: colors.from }}
      />

      {/* Middle pulsing square */}
      <motion.div
        animate={{
          rotate: [0, -45, 0, 45, 0],
          scale: [0.8, 1, 0.8, 1, 0.8],
        }}
        transition={{
          duration: 3,
          repeat: Infinity,
          ease: 'easeInOut',
        }}
        className="absolute w-20 h-20"
        style={{
          background: `linear-gradient(135deg, ${colors.from}, ${colors.to})`,
          clipPath: 'polygon(50% 0%, 100% 50%, 50% 100%, 0% 50%)',
        }}
      />

      {/* Inner breathing circle */}
      <motion.div
        animate={{
          scale: [0.9, 1.1, 0.9],
          opacity: [0.7, 1, 0.7],
        }}
        transition={{
          duration: 2,
          repeat: Infinity,
          ease: 'easeInOut',
        }}
        className="absolute w-12 h-12 rounded-full"
        style={{
          background: `radial-gradient(circle, ${colors.to}, ${colors.from})`,
        }}
      />

      {/* Orbiting dots */}
      {[0, 1, 2].map((i) => (
        <motion.div
          key={i}
          animate={{
            rotate: 360,
          }}
          transition={{
            duration: 3 + i * 0.5,
            repeat: Infinity,
            ease: 'linear',
          }}
          className="absolute w-32 h-32"
          style={{
            transform: `rotate(${i * 120}deg)`,
          }}
        >
          <motion.div
            className="absolute w-3 h-3 rounded-full"
            style={{
              top: 0,
              left: '50%',
              marginLeft: '-6px',
              backgroundColor: colors.from,
            }}
            animate={{
              opacity: [0.4, 1, 0.4],
            }}
            transition={{
              duration: 1.5,
              repeat: Infinity,
              delay: i * 0.3,
            }}
          />
        </motion.div>
      ))}
    </div>
  );
}
```

Design choices:
- Color gradient shifts between stages
- Multiple layered animations create depth
- Diamond shape (joinery reference without being literal)
- Orbiting elements suggest processing activity
  </action>
  <verify>Animation renders smoothly without jank</verify>
  <done>Abstract geometric animation with stage-based colors</done>
</task>

<task type="auto">
  <name>Task 3: Create Error Fallback and Processing Screen</name>
  <files>
src/components/processing/ErrorFallback.tsx
src/components/processing/ProcessingScreen.tsx
  </files>
  <action>
Create error handling UI (per CONTEXT.md: "Something went wrong. Try again?"):

**ErrorFallback.tsx:**
```typescript
'use client';

import { motion } from 'framer-motion';
import { AlertCircle, RefreshCw, Camera } from 'lucide-react';
import { Button } from '@/components/ui/button';

interface ErrorFallbackProps {
  error: string;
  isRoomDetectionError?: boolean;
  onRetry: () => void;
  onRetake?: () => void;
}

export function ErrorFallback({
  error,
  isRoomDetectionError,
  onRetry,
  onRetake,
}: ErrorFallbackProps) {
  return (
    <motion.div
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      className="flex flex-col items-center justify-center p-8 text-center"
    >
      <div className="w-16 h-16 rounded-full bg-red-500/10 flex items-center justify-center mb-6">
        <AlertCircle className="w-8 h-8 text-red-500" />
      </div>

      {isRoomDetectionError ? (
        <>
          <h2 className="text-xl font-semibold text-white mb-2">
            We couldn&apos;t detect a room
          </h2>
          <p className="text-gray-400 mb-6 max-w-xs">
            Tips: Make sure walls are visible, improve lighting, and stand back to capture more of the space.
          </p>
          <div className="flex gap-3">
            {onRetake && (
              <Button onClick={onRetake} variant="outline">
                <Camera className="w-4 h-4 mr-2" />
                Retake Photo
              </Button>
            )}
            <Button onClick={onRetry}>
              <RefreshCw className="w-4 h-4 mr-2" />
              Try Again
            </Button>
          </div>
        </>
      ) : (
        <>
          <h2 className="text-xl font-semibold text-white mb-2">
            Something went wrong
          </h2>
          <p className="text-gray-400 mb-6 max-w-xs">{error}</p>
          <Button onClick={onRetry} className="min-w-32">
            <RefreshCw className="w-4 h-4 mr-2" />
            Try Again
          </Button>
        </>
      )}
    </motion.div>
  );
}
```

**ProcessingScreen.tsx:**
```typescript
'use client';

import { motion, AnimatePresence } from 'framer-motion';
import { PipelineStage, PipelineProgress } from '@/types/ai-pipeline';
import { StepIndicator } from './StepIndicator';
import { GeometricAnimation } from './GeometricAnimation';
import { ErrorFallback } from './ErrorFallback';

interface ProcessingScreenProps {
  progress: PipelineProgress;
  error?: string;
  onRetry: () => void;
  onRetake?: () => void;
}

export function ProcessingScreen({
  progress,
  error,
  onRetry,
  onRetake,
}: ProcessingScreenProps) {
  const isRoomDetectionError = error?.toLowerCase().includes('room') ||
    error?.toLowerCase().includes('detect');

  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      className="fixed inset-0 bg-zinc-900 z-50 flex flex-col"
    >
      {/* Header spacer for status bar */}
      <div className="h-safe-top" />

      <div className="flex-1 flex flex-col items-center justify-center px-6">
        <AnimatePresence mode="wait">
          {error ? (
            <ErrorFallback
              key="error"
              error={error}
              isRoomDetectionError={isRoomDetectionError}
              onRetry={onRetry}
              onRetake={onRetake}
            />
          ) : (
            <motion.div
              key="processing"
              initial={{ opacity: 0 }}
              animate={{ opacity: 1 }}
              exit={{ opacity: 0 }}
              className="w-full max-w-md"
            >
              {/* Title */}
              <motion.h1
                className="text-2xl font-semibold text-white text-center mb-8"
                initial={{ opacity: 0, y: -10 }}
                animate={{ opacity: 1, y: 0 }}
              >
                Creating your designs
              </motion.h1>

              {/* Geometric animation */}
              <GeometricAnimation stage={progress.stage} />

              {/* Step indicator */}
              <div className="mt-8">
                <StepIndicator
                  currentStage={progress.stage}
                  completedStages={progress.stagesComplete}
                />
              </div>

              {/* Subtle message */}
              <motion.p
                className="text-gray-500 text-sm text-center mt-8"
                initial={{ opacity: 0 }}
                animate={{ opacity: 1 }}
                transition={{ delay: 0.5 }}
              >
                Analyzing your space and preparing styled options
              </motion.p>
            </motion.div>
          )}
        </AnimatePresence>
      </div>

      {/* Bottom safe area */}
      <div className="h-safe-bottom" />
    </motion.div>
  );
}
```

Key features:
- Full-screen overlay during processing
- Smooth transitions between processing and error states
- Room detection error has specific guidance (per CONTEXT.md)
- No cancel option (per CONTEXT.md: committed flow)
  </action>
  <verify>Both components render, error state shows retry button</verify>
  <done>Processing screen with animated progress and error handling</done>
</task>

</tasks>

<verification>
- [ ] `npm run typecheck` passes
- [ ] All 4 components created in src/components/processing/
- [ ] StepIndicator shows 4 stages with animation
- [ ] GeometricAnimation runs smoothly
- [ ] ErrorFallback shows retry option
- [ ] ProcessingScreen integrates all components
</verification>

<success_criteria>
- Processing UI provides clear visual feedback
- Stage names match CONTEXT.md: Analyzing/Measuring/Styling/Creating (contractual labels)
- No time estimates shown (per CONTEXT.md decision)
- Error handling with retry and retake options
- Animations are smooth and modern (not literal)
</success_criteria>

<output>
After completion, create `.planning/phases/03-ai-pipeline/03-04-SUMMARY.md`
</output>
