---
phase: 03-ai-pipeline
plan: 05
type: execute
wave: 3
depends_on: ["03-01", "03-02", "03-03"]
files_modified:
  - src/components/renders/RenderCarousel.tsx
  - src/lib/hooks/useProcessPhoto.ts
  - src/app/(tabs)/page.tsx
autonomous: true

must_haves:
  truths:
    - "User can swipe through 3 rendered designs"
    - "Pagination dots show current position"
    - "Customize this button is accessible on each render"
    - "Photo capture triggers full pipeline flow"
    - "Progress updates in real-time as stages complete"
  artifacts:
    - path: "src/components/renders/RenderCarousel.tsx"
      provides: "Swipeable render gallery"
      exports: ["RenderCarousel"]
    - path: "src/lib/hooks/useProcessPhoto.ts"
      provides: "Pipeline orchestration hook"
      exports: ["useProcessPhoto"]
  key_links:
    - from: "src/lib/hooks/useProcessPhoto.ts"
      to: "convex/ai.ts"
      via: "useAction hook"
      pattern: "useAction.*analyze|generate"
    - from: "src/app/(tabs)/page.tsx"
      to: "src/components/processing/ProcessingScreen.tsx"
      via: "conditional render"
      pattern: "ProcessingScreen"
    - from: "src/app/(tabs)/page.tsx"
      to: "src/components/renders/RenderCarousel.tsx"
      via: "conditional render"
      pattern: "RenderCarousel"
---

<objective>
Build the render carousel and integrate the full AI pipeline into the camera capture flow.

Purpose: Complete the user journey from photo capture through processing to viewing styled renders.
Output: Working end-to-end flow: capture photo -> processing screen -> render carousel with "Customize this" CTA.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/03-ai-pipeline/03-CONTEXT.md
@.planning/phases/03-ai-pipeline/03-RESEARCH.md
@.planning/phases/03-ai-pipeline/03-01-SUMMARY.md
@.planning/phases/03-ai-pipeline/03-02-SUMMARY.md
@.planning/phases/03-ai-pipeline/03-03-SUMMARY.md
@src/types/ai-pipeline.ts
@src/app/(tabs)/page.tsx
@src/lib/ai/claude-vision.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Render Carousel Component</name>
  <files>src/components/renders/RenderCarousel.tsx</files>
  <action>
Create swipeable full-screen carousel (per CONTEXT.md: "swipe left/right, dots indicator"):

```typescript
'use client';

import { useState } from 'react';
import { motion, AnimatePresence, PanInfo } from 'framer-motion';
import { Button } from '@/components/ui/button';
import { Render, Dimensions } from '@/types/ai-pipeline';
import { ChevronLeft } from 'lucide-react';

interface RenderCarouselProps {
  renders: Render[];
  dimensions: Dimensions;
  onCustomize: (render: Render) => void;
  onBack: () => void;
}

export function RenderCarousel({
  renders,
  dimensions,
  onCustomize,
  onBack,
}: RenderCarouselProps) {
  const [currentIndex, setCurrentIndex] = useState(0);
  const [direction, setDirection] = useState(0);

  const slideVariants = {
    enter: (direction: number) => ({
      x: direction > 0 ? '100%' : '-100%',
      opacity: 0,
    }),
    center: {
      x: 0,
      opacity: 1,
    },
    exit: (direction: number) => ({
      x: direction < 0 ? '100%' : '-100%',
      opacity: 0,
    }),
  };

  const swipeConfidenceThreshold = 10000;
  const swipePower = (offset: number, velocity: number) => {
    return Math.abs(offset) * velocity;
  };

  const paginate = (newDirection: number) => {
    const newIndex = currentIndex + newDirection;
    if (newIndex >= 0 && newIndex < renders.length) {
      setDirection(newDirection);
      setCurrentIndex(newIndex);
    }
  };

  const handleDragEnd = (
    _: MouseEvent | TouchEvent | PointerEvent,
    { offset, velocity }: PanInfo
  ) => {
    const swipe = swipePower(offset.x, velocity.x);

    if (swipe < -swipeConfidenceThreshold) {
      paginate(1);
    } else if (swipe > swipeConfidenceThreshold) {
      paginate(-1);
    }
  };

  const currentRender = renders[currentIndex];

  return (
    <motion.div
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      className="fixed inset-0 bg-black z-50 flex flex-col"
    >
      {/* Header */}
      <div className="absolute top-0 left-0 right-0 z-10 pt-safe-top">
        <div className="flex items-center justify-between px-4 py-3">
          <button
            onClick={onBack}
            className="w-10 h-10 rounded-full bg-black/40 backdrop-blur-sm flex items-center justify-center"
          >
            <ChevronLeft className="w-6 h-6 text-white" />
          </button>

          {/* Style label */}
          <div className="px-4 py-2 bg-black/40 backdrop-blur-sm rounded-full">
            <span className="text-white font-medium">{currentRender.styleLabel}</span>
          </div>

          {/* Spacer */}
          <div className="w-10" />
        </div>
      </div>

      {/* Render image - swipeable */}
      <div className="flex-1 relative overflow-hidden">
        <AnimatePresence initial={false} custom={direction}>
          <motion.div
            key={currentIndex}
            custom={direction}
            variants={slideVariants}
            initial="enter"
            animate="center"
            exit="exit"
            transition={{
              x: { type: 'spring', stiffness: 300, damping: 30 },
              opacity: { duration: 0.2 },
            }}
            drag="x"
            dragConstraints={{ left: 0, right: 0 }}
            dragElastic={1}
            onDragEnd={handleDragEnd}
            className="absolute inset-0"
          >
            <img
              src={currentRender.imageUrl}
              alt={`${currentRender.styleLabel} render`}
              className="w-full h-full object-cover"
              draggable={false}
            />
          </motion.div>
        </AnimatePresence>

        {/* Swipe hint overlay (first time) */}
        <div className="absolute inset-0 pointer-events-none flex items-center justify-center">
          {/* Could add first-time swipe hint here */}
        </div>
      </div>

      {/* Bottom controls */}
      <div className="absolute bottom-0 left-0 right-0 pb-safe-bottom bg-gradient-to-t from-black/80 to-transparent pt-20">
        {/* Pagination dots */}
        <div className="flex justify-center gap-2 mb-4">
          {renders.map((_, index) => (
            <button
              key={index}
              onClick={() => {
                setDirection(index > currentIndex ? 1 : -1);
                setCurrentIndex(index);
              }}
              className={`w-2 h-2 rounded-full transition-all ${
                index === currentIndex
                  ? 'bg-white w-6'
                  : 'bg-white/50'
              }`}
              aria-label={`Go to render ${index + 1}`}
            />
          ))}
        </div>

        {/* Dimension badge (subtle) */}
        <div className="flex justify-center mb-4">
          <div className="px-3 py-1 bg-white/10 rounded-full">
            <span className="text-white/70 text-xs">
              {dimensions.width} x {dimensions.depth} x {dimensions.height}mm
              <span className="ml-2 text-white/50">
                ({dimensions.tierLabel})
              </span>
            </span>
          </div>
        </div>

        {/* CTA Button */}
        <div className="px-6 pb-4">
          <Button
            onClick={() => onCustomize(currentRender)}
            className="w-full h-14 text-lg"
          >
            Customize this
          </Button>
        </div>

        {/* Disclaimer */}
        <p className="text-white/40 text-xs text-center px-6 pb-4">
          Estimates from photo â€” site measure confirms final dimensions
        </p>
      </div>
    </motion.div>
  );
}
```

Key features:
- Full-screen swipeable carousel with spring physics
- Pagination dots with active indicator
- Style label in header
- Dimension display with confidence tier
- Disclaimer text (per CONTEXT.md)
- "Customize this" CTA at bottom
  </action>
  <verify>Carousel renders with swipe gestures working</verify>
  <done>Full-screen swipeable render carousel with pagination</done>
</task>

<task type="auto">
  <name>Task 2: Create Pipeline Orchestration Hook</name>
  <files>src/lib/hooks/useProcessPhoto.ts</files>
  <action>
Create TanStack Query mutation hook that orchestrates the full pipeline:

```typescript
'use client';

import { useState, useCallback } from 'react';
import { useMutation } from '@tanstack/react-query';
import { useAction } from 'convex/react';
import { api } from '../../convex/_generated/api';
import {
  PipelineStage,
  PipelineProgress,
  PipelineResult,
  SpaceAnalysis,
  Dimensions,
} from '@/types/ai-pipeline';
import { imageUriToBase64, resizeImageForVision } from '@/lib/ai/claude-vision';
import { estimateDimensions } from '@/lib/ai/depth-estimation';
import { getStylesForSpace } from '@/lib/ai/render-generation';

export function useProcessPhoto() {
  const [progress, setProgress] = useState<PipelineProgress>({
    stage: 'analyzing',
    stagesComplete: [],
  });

  const analyzeSpace = useAction(api.ai.analyzeSpaceAction);
  const generateRenders = useAction(api.ai.generateRendersAction);

  const advanceStage = useCallback((stage: PipelineStage) => {
    setProgress((prev) => ({
      stage,
      stagesComplete: prev.stage !== stage
        ? [...prev.stagesComplete, prev.stage]
        : prev.stagesComplete,
    }));
  }, []);

  const mutation = useMutation({
    mutationFn: async (imageUri: string): Promise<PipelineResult> => {
      // Reset progress
      setProgress({ stage: 'analyzing', stagesComplete: [] });

      // Step 1: Convert and resize image
      const base64Raw = await imageUriToBase64(imageUri);
      const imageBase64 = await resizeImageForVision(base64Raw);

      // Step 2: Analyze space with Claude Vision
      advanceStage('analyzing');
      const analysisResult = await analyzeSpace({ imageBase64 });

      if (!analysisResult.success || !analysisResult.analysis) {
        throw new Error(analysisResult.error || 'Space analysis failed');
      }

      const analysis: SpaceAnalysis = analysisResult.analysis;

      // Step 3: Estimate dimensions
      advanceStage('measuring');
      const dimensions: Dimensions = estimateDimensions(analysis, 'basic');

      // Step 4: Get style matches
      advanceStage('styling');
      const styles = getStylesForSpace(analysis);

      // Step 5: Generate renders
      advanceStage('creating');
      const renderResult = await generateRenders({
        imageBase64,
        styles,
        roomType: analysis.roomType,
        dimensions: {
          width: dimensions.width,
          depth: dimensions.depth,
          height: dimensions.height,
        },
        styleAesthetic: analysis.styleAesthetic,
        lightingConditions: analysis.lightingConditions,
      });

      if (!renderResult.renders || renderResult.renders.length === 0) {
        throw new Error('No renders could be generated. Please try again.');
      }

      // Transform renders to include full image URLs
      const renders = renderResult.renders.map((r: any) => ({
        id: r.id,
        styleLabel: r.styleLabel,
        styleId: r.styleId,
        imageUrl: `data:image/jpeg;base64,${r.imageBase64}`,
        imageBase64: r.imageBase64,
      }));

      return {
        analysis,
        dimensions,
        styles,
        renders,
      };
    },
    onError: (error) => {
      setProgress((prev) => ({
        ...prev,
        error: error instanceof Error ? error.message : 'Unknown error',
      }));
    },
  });

  const reset = useCallback(() => {
    mutation.reset();
    setProgress({ stage: 'analyzing', stagesComplete: [] });
  }, [mutation]);

  return {
    processPhoto: mutation.mutate,
    isProcessing: mutation.isPending,
    error: mutation.error?.message || progress.error,
    result: mutation.data,
    progress,
    reset,
  };
}
```

Key features:
- Orchestrates all 4 pipeline stages
- Updates progress state after each stage
- Handles errors at any stage
- Returns structured result with analysis, dimensions, styles, renders
- Reset function for retry flow
  </action>
  <verify>`npm run typecheck` passes, hook exported</verify>
  <done>Pipeline orchestration hook with progress tracking</done>
</task>

<task type="auto">
  <name>Task 3: Integrate Pipeline into Home Page</name>
  <files>src/app/(tabs)/page.tsx</files>
  <action>
Wire up the full pipeline flow in the Home page:

1. Import new components and hook
2. Add state for pipeline flow
3. Connect camera capture to pipeline
4. Show ProcessingScreen during processing
5. Show RenderCarousel when complete
6. Handle "Customize this" (stub for Phase 04)

```typescript
// Add imports
import { useState } from 'react';
import { useProcessPhoto } from '@/lib/hooks/useProcessPhoto';
import { ProcessingScreen } from '@/components/processing/ProcessingScreen';
import { RenderCarousel } from '@/components/renders/RenderCarousel';
import { Render } from '@/types/ai-pipeline';

// Inside the component:

// Pipeline state
const {
  processPhoto,
  isProcessing,
  error,
  result,
  progress,
  reset,
} = useProcessPhoto();

// View state: 'camera' | 'processing' | 'renders'
const [view, setView] = useState<'camera' | 'processing' | 'renders'>('camera');

// Handle photo acceptance from camera
const handlePhotoAccepted = useCallback((photoUri: string) => {
  setView('processing');
  processPhoto(photoUri, {
    onSuccess: () => {
      setView('renders');
    },
    onError: () => {
      // Stay on processing screen to show error
    },
  });
}, [processPhoto]);

// Handle retry
const handleRetry = useCallback(() => {
  reset();
  setView('camera');
  setIsCameraOpen(true);
}, [reset]);

// Handle "Customize this"
const handleCustomize = useCallback((render: Render) => {
  // Store selected render and dimensions for Phase 04
  console.log('Selected render:', render.styleId);
  console.log('Dimensions:', result?.dimensions);
  // TODO: Navigate to configurator with selected style
}, [result]);

// Handle back from carousel
const handleBackFromCarousel = useCallback(() => {
  reset();
  setView('camera');
}, [reset]);

// In the render, add conditional rendering:

{/* Processing Screen */}
{view === 'processing' && (
  <ProcessingScreen
    progress={progress}
    error={error}
    onRetry={handleRetry}
    onRetake={handleRetry}
  />
)}

{/* Render Carousel */}
{view === 'renders' && result && (
  <RenderCarousel
    renders={result.renders}
    dimensions={result.dimensions}
    onCustomize={handleCustomize}
    onBack={handleBackFromCarousel}
  />
)}
```

Make sure to:
- Pass `handlePhotoAccepted` to CameraCapture's `onPhotoAccepted` prop
- Hide the main camera UI when in processing/renders view
- Handle the transition between camera -> processing -> renders
  </action>
  <verify>Full flow works: capture -> processing -> renders -> customize stub</verify>
  <done>Complete pipeline integration in Home page</done>
</task>

</tasks>

<verification>
- [ ] `npm run typecheck` passes
- [ ] RenderCarousel shows swipeable renders with pagination
- [ ] useProcessPhoto orchestrates all pipeline stages
- [ ] Home page transitions through camera -> processing -> renders
- [ ] Error state shows retry option
- [ ] "Customize this" logs selected render (stub for Phase 04)
</verification>

<success_criteria>
- Carousel supports swipe gestures with spring physics
- Pagination dots indicate position
- Dimension badge shows estimates with tier label
- Pipeline hook tracks progress through all stages
- Full flow integrated into Home page
- "Customize this" ready for Phase 04 wiring
</success_criteria>

<output>
After completion, create `.planning/phases/03-ai-pipeline/03-05-SUMMARY.md`
</output>
