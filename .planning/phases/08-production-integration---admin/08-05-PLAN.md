---
phase: 08-production-integration-admin
plan: 05
type: execute
wave: 2
depends_on: ["08-01", "08-02", "08-03"]
files_modified:
  - src/components/admin/SpecDownloader.tsx
  - src/components/admin/OrderCard.tsx
  - src/lib/pdf/transformOrderToSpec.ts
autonomous: true

must_haves:
  truths:
    - "Admin can download production spec as PDF"
    - "Admin can download panel schedule as CSV"
    - "Admin can download hardware list as CSV"
    - "PDF renders correctly in browser"
    - "CSV opens correctly in Excel/Sheets"
  artifacts:
    - path: "src/components/admin/SpecDownloader.tsx"
      provides: "PDF/CSV download buttons"
      exports: ["SpecDownloader"]
    - path: "src/lib/pdf/transformOrderToSpec.ts"
      provides: "Order data to spec data transformer"
      exports: ["transformOrderToSpec"]
  key_links:
    - from: "src/components/admin/SpecDownloader.tsx"
      to: "src/lib/pdf/ProductionSpecPDF.tsx"
      via: "PDFDownloadLink with dynamic import"
      pattern: "dynamic.*@react-pdf/renderer"
    - from: "src/components/admin/SpecDownloader.tsx"
      to: "src/lib/csv/index.ts"
      via: "downloadPanelCSV and downloadHardwareCSV"
      pattern: "download.*CSV"
---

<objective>
Wire PDF and CSV download functionality into admin order management.

Purpose: Enable admin to download production specs (PDF) and spreadsheet exports (CSV) for factory/workshop use directly from the order detail view.
Output: SpecDownloader component with PDF/CSV buttons integrated into OrderCard.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-production-integration---admin/08-RESEARCH.md

# PDF/CSV infrastructure from Plans 01 and 02
@src/lib/pdf/ProductionSpecPDF.tsx
@src/lib/pdf/types.ts
@src/lib/csv/index.ts

# Admin components from Plan 03
@src/components/admin/OrderCard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create order-to-spec data transformer</name>
  <files>src/lib/pdf/transformOrderToSpec.ts</files>
  <action>
Create a function to transform order/design data into ProductionSpecData format:

**src/lib/pdf/transformOrderToSpec.ts:**
```typescript
import type { ProductionSpecData, CabinetItem, PanelItem, HardwareItem, EdgeBandingItem } from "./types";

interface OrderData {
  orderNumber: string;
  createdAt: number;
  submission?: {
    name: string;
    email: string;
    siteMeasure: boolean;
    installQuote: boolean;
    notes?: string;
  } | null;
  design?: {
    productType: string;
    config?: {
      dimensions?: { width: number; height: number; depth: number };
      slots?: Array<{
        position: number;
        module?: {
          type: string;
          interiorConfig?: any;
        } | null;
      }>;
      finishes?: {
        material?: { code: string; name: string };
        hardware?: { code: string; name: string; pricePerUnit: number };
        doorProfile?: { code: string; name: string };
      };
    };
  } | null;
}

/**
 * Transform order data from Convex into ProductionSpecData for PDF/CSV generation
 *
 * This function extracts and flattens nested design config into a format
 * suitable for production documentation.
 */
export function transformOrderToSpec(order: OrderData): ProductionSpecData {
  const config = order.design?.config || {};
  const dimensions = config.dimensions || { width: 2400, height: 800, depth: 560 };
  const slots = config.slots || [];
  const finishes = config.finishes || {};

  // Generate cabinets from slots
  const cabinets: CabinetItem[] = slots
    .filter((slot) => slot.module)
    .map((slot, index) => ({
      id: `CAB-${String(index + 1).padStart(2, "0")}`,
      type: slot.module?.type || "Unknown",
      position: slot.position,
      width: 600, // Default slot width
      height: dimensions.height,
      depth: dimensions.depth,
      interiorConfig: formatInteriorConfig(slot.module?.interiorConfig),
    }));

  // Generate panels from cabinets
  // Each cabinet generates: Left Side, Right Side, Back, Top, Bottom, plus shelves/doors
  const panels: PanelItem[] = [];
  const materialCode = finishes.material?.code || "Unknown";

  cabinets.forEach((cab, cabIndex) => {
    const panelPrefix = `P${String(cabIndex + 1).padStart(2, "0")}`;

    // Standard panels for each cabinet
    const standardPanels: Array<Omit<PanelItem, "id" | "cabinetRef">> = [
      { name: "Left Side", width: cab.depth, height: cab.height, thickness: 18, material: materialCode, grainDirection: "vertical" as const, edgeLeft: true },
      { name: "Right Side", width: cab.depth, height: cab.height, thickness: 18, material: materialCode, grainDirection: "vertical" as const, edgeRight: true },
      { name: "Back", width: cab.width - 36, height: cab.height - 18, thickness: 6, material: materialCode },
      { name: "Top Rail", width: cab.width - 36, height: 100, thickness: 18, material: materialCode },
      { name: "Bottom", width: cab.width - 36, height: cab.depth - 18, thickness: 18, material: materialCode, edgeTop: true },
    ];

    standardPanels.forEach((panel, panelIndex) => {
      panels.push({
        ...panel,
        id: `${panelPrefix}-${String(panelIndex + 1).padStart(2, "0")}`,
        cabinetRef: cab.id,
      });
    });
  });

  // Calculate edge banding summary
  const edgeBanding: EdgeBandingItem[] = calculateEdgeBanding(panels, finishes.material?.name || "Unknown");

  // Generate hardware list based on cabinet types
  const hardware: HardwareItem[] = generateHardwareList(cabinets, finishes.hardware);

  return {
    orderNumber: order.orderNumber,
    customerName: order.submission?.name || "Unknown",
    customerEmail: order.submission?.email || "",
    createdAt: new Date(order.createdAt).toLocaleDateString("en-AU", {
      day: "numeric",
      month: "long",
      year: "numeric",
    }),
    cabinets,
    panels,
    hardware,
    edgeBanding,
    notes: order.submission?.notes,
  };
}

function formatInteriorConfig(config: any): string | undefined {
  if (!config) return undefined;

  const parts: string[] = [];
  if (config.shelfCount) parts.push(`${config.shelfCount} shelves`);
  if (config.drawerCount) parts.push(`${config.drawerCount} drawers`);
  if (config.dividers) parts.push("dividers");
  if (config.ledStrip) parts.push("LED strip");
  if (config.pullOutBin) parts.push("pull-out bin");

  return parts.length > 0 ? parts.join(", ") : undefined;
}

function calculateEdgeBanding(panels: PanelItem[], materialName: string): EdgeBandingItem[] {
  // Count panels with edges
  let totalLength = 0;
  let panelCount = 0;

  panels.forEach((panel) => {
    const edges = [panel.edgeTop, panel.edgeBottom, panel.edgeLeft, panel.edgeRight].filter(Boolean);
    if (edges.length > 0) {
      panelCount++;
      // Calculate edge length in mm, convert to meters
      if (panel.edgeTop || panel.edgeBottom) totalLength += panel.width * edges.filter((_, i) => i < 2).length;
      if (panel.edgeLeft || panel.edgeRight) totalLength += panel.height * edges.filter((_, i) => i >= 2).length;
    }
  });

  if (panelCount === 0) return [];

  return [{
    material: materialName,
    thickness: "1mm",
    totalLength: totalLength / 1000, // Convert to meters
    panelCount,
  }];
}

function generateHardwareList(cabinets: CabinetItem[], hardwareOption: any): HardwareItem[] {
  const hardware: HardwareItem[] = [];

  // Count doors and drawers
  let doorCount = 0;
  let drawerCount = 0;

  cabinets.forEach((cab) => {
    // Estimate based on cabinet type
    if (cab.type.includes("Drawer")) {
      drawerCount += 3; // Assume drawer stack has 3 drawers
    } else if (cab.type.includes("Door") || cab.type === "StandardBase" || cab.type === "StandardOverhead") {
      doorCount += 1;
    }
  });

  // Hinges (2 per door)
  if (doorCount > 0) {
    hardware.push({
      code: hardwareOption?.code || "BLUM-CLIP-110",
      name: "Blum CLIP top 110 hinge",
      supplier: "Blum",
      quantity: doorCount * 2,
      unitPrice: hardwareOption?.pricePerUnit || 1200, // $12 in cents
    });
  }

  // Drawer runners
  if (drawerCount > 0) {
    hardware.push({
      code: "BLUM-TANDEM-500",
      name: "Blum TANDEM 500mm drawer runner (pair)",
      supplier: "Blum",
      quantity: drawerCount,
      unitPrice: 4500, // $45 in cents
    });
  }

  // Soft close (one per door/drawer)
  const softCloseCount = doorCount + drawerCount;
  if (softCloseCount > 0) {
    hardware.push({
      code: "BLUM-BLUMOTION",
      name: "Blum BLUMOTION soft close",
      supplier: "Blum",
      quantity: softCloseCount,
      unitPrice: 800, // $8 in cents
    });
  }

  return hardware;
}
```

This transformer:
- Extracts design config from nested order data
- Generates cabinet list from slots
- Calculates panel cut list with standard panel sizes
- Generates hardware BOM based on cabinet types
- Calculates edge banding totals
  </action>
  <verify>npx tsc --noEmit src/lib/pdf/transformOrderToSpec.ts</verify>
  <done>Transformer function converts order data to ProductionSpecData format</done>
</task>

<task type="auto">
  <name>Task 2: Create SpecDownloader component</name>
  <files>src/components/admin/SpecDownloader.tsx</files>
  <action>
Create the spec downloader component with PDF and CSV buttons:

**src/components/admin/SpecDownloader.tsx:**
```typescript
"use client";

import { useState } from "react";
import dynamic from "next/dynamic";
import { Button } from "@/components/ui/button";
import { FileText, FileSpreadsheet, Loader2, QrCode, Printer } from "lucide-react";
import { downloadPanelCSV, downloadHardwareCSV } from "@/lib/csv";
import { transformOrderToSpec } from "@/lib/pdf/transformOrderToSpec";
import type { ProductionSpecData } from "@/lib/pdf/types";

// Dynamic import for PDF components - required for Next.js static export
// IMPORTANT per RESEARCH.md: @react-pdf/renderer cannot SSR
const PDFDownloadLink = dynamic(
  () => import("@react-pdf/renderer").then((mod) => mod.PDFDownloadLink),
  {
    ssr: false,
    loading: () => (
      <Button variant="outline" disabled>
        <Loader2 className="h-4 w-4 mr-2 animate-spin" />
        Loading PDF...
      </Button>
    ),
  }
);

// Dynamically import ProductionSpecPDF to avoid SSR issues
const ProductionSpecPDF = dynamic(
  () => import("@/lib/pdf/ProductionSpecPDF").then((mod) => mod.ProductionSpecPDF),
  { ssr: false }
);

interface SpecDownloaderProps {
  order: {
    _id: string;
    orderNumber: string;
    createdAt: number;
    submission?: {
      name: string;
      email: string;
      siteMeasure: boolean;
      installQuote: boolean;
      notes?: string;
    } | null;
    design?: {
      productType: string;
      config?: any;
    } | null;
  };
}

export function SpecDownloader({ order }: SpecDownloaderProps) {
  const [pdfReady, setPdfReady] = useState(false);

  // Transform order to spec data
  const specData = transformOrderToSpec(order);

  const handlePanelCSV = () => {
    downloadPanelCSV(specData.panels, order.orderNumber);
  };

  const handleHardwareCSV = () => {
    downloadHardwareCSV(specData.hardware, order.orderNumber);
  };

  return (
    <div className="space-y-4">
      <p className="text-sm font-medium text-zinc-700 dark:text-zinc-300">
        Download Production Specs
      </p>

      <div className="grid grid-cols-1 sm:grid-cols-2 gap-2">
        {/* PDF Download */}
        <PDFDownloadLink
          document={<ProductionSpecPDF data={specData} />}
          fileName={`${order.orderNumber}-production-spec.pdf`}
        >
          {({ loading, error }) => (
            <Button
              variant="outline"
              disabled={loading}
              className="w-full justify-start"
            >
              {loading ? (
                <Loader2 className="h-4 w-4 mr-2 animate-spin" />
              ) : (
                <FileText className="h-4 w-4 mr-2" />
              )}
              {loading ? "Generating PDF..." : "Production Spec (PDF)"}
            </Button>
          )}
        </PDFDownloadLink>

        {/* Panel Schedule CSV */}
        <Button
          variant="outline"
          onClick={handlePanelCSV}
          className="w-full justify-start"
        >
          <FileSpreadsheet className="h-4 w-4 mr-2" />
          Panel Schedule (CSV)
        </Button>

        {/* Hardware List CSV */}
        <Button
          variant="outline"
          onClick={handleHardwareCSV}
          className="w-full justify-start"
        >
          <FileSpreadsheet className="h-4 w-4 mr-2" />
          Hardware List (CSV)
        </Button>

        {/* QR Labels - links to printable page */}
        <Button
          variant="outline"
          onClick={() => {
            // Open QR label sheet in new window for printing
            window.open(`/admin/orders/${order._id}/qr-labels`, "_blank");
          }}
          className="w-full justify-start"
        >
          <QrCode className="h-4 w-4 mr-2" />
          QR Labels (Print)
        </Button>
      </div>

      <p className="text-xs text-zinc-500">
        PDF includes: header, cabinet schedule, panel schedule, edge banding, hardware list.
        CSV files can be imported into Excel or Google Sheets.
      </p>
    </div>
  );
}
```

IMPORTANT per RESEARCH.md:
- PDFDownloadLink must use dynamic import with ssr: false
- ProductionSpecPDF also needs dynamic import to avoid SSR issues
- CSV downloads work synchronously via blob download
  </action>
  <verify>npm run build passes without "window is not defined" errors</verify>
  <done>SpecDownloader component created with PDF and CSV download buttons</done>
</task>

<task type="auto">
  <name>Task 3: Integrate SpecDownloader into OrderCard and create QR labels page</name>
  <files>src/components/admin/OrderCard.tsx, src/app/admin/orders/[id]/qr-labels/page.tsx</files>
  <action>
First, add SpecDownloader to OrderCard:

Add import at top of src/components/admin/OrderCard.tsx:
```typescript
import { SpecDownloader } from "./SpecDownloader";
```

Add a new collapsible section in the expanded content, after the Notification Trigger section:

```typescript
{/* Production Specs section */}
<div className="mt-4 pt-4 border-t border-zinc-100 dark:border-zinc-700">
  <details className="group">
    <summary className="flex items-center justify-between cursor-pointer list-none">
      <p className="text-sm font-medium text-zinc-700 dark:text-zinc-300">
        Production Specs
      </p>
      <ChevronDown className="h-4 w-4 text-zinc-400 transition-transform group-open:rotate-180" />
    </summary>
    <div className="mt-4">
      <SpecDownloader order={order} />
    </div>
  </details>
</div>
```

Then create the QR labels print page:

**src/app/admin/orders/[id]/qr-labels/page.tsx:**
```typescript
"use client";

import { useEffect, useState } from "react";
import { useParams } from "next/navigation";
import { useQuery } from "convex/react";
import { api } from "../../../../../../convex/_generated/api";
import type { Id } from "../../../../../../convex/_generated/dataModel";
import { QRLabelSheet, printStyles } from "@/lib/qr";
import { transformOrderToSpec } from "@/lib/pdf/transformOrderToSpec";
import { Loader2, Printer } from "lucide-react";
import { Button } from "@/components/ui/button";

export default function QRLabelsPage() {
  const params = useParams();
  const orderId = params.id as Id<"orders">;

  const order = useQuery(api.orders.get, { id: orderId });

  // Add print styles to document
  useEffect(() => {
    const style = document.createElement("style");
    style.textContent = printStyles;
    document.head.appendChild(style);
    return () => {
      document.head.removeChild(style);
    };
  }, []);

  if (order === undefined) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <Loader2 className="h-8 w-8 animate-spin text-zinc-400" />
      </div>
    );
  }

  if (order === null) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <p className="text-zinc-500">Order not found</p>
      </div>
    );
  }

  // Transform order to get panel data
  const specData = transformOrderToSpec(order);
  const panelLabels = specData.panels.map((panel) => ({
    panelId: panel.id,
    cabinetRef: panel.cabinetRef,
    dimensions: `${panel.width} x ${panel.height} x ${panel.thickness}mm`,
    material: panel.material,
  }));

  const handlePrint = () => {
    window.print();
  };

  return (
    <div className="min-h-screen bg-white">
      {/* Print button - hidden when printing */}
      <div className="print:hidden fixed top-4 right-4 z-10">
        <Button onClick={handlePrint}>
          <Printer className="h-4 w-4 mr-2" />
          Print Labels
        </Button>
      </div>

      {/* Page header - hidden when printing */}
      <div className="print:hidden p-6 border-b">
        <h1 className="text-xl font-bold">QR Labels - {order.orderNumber}</h1>
        <p className="text-sm text-zinc-500 mt-1">
          {panelLabels.length} panels
        </p>
      </div>

      {/* QR Label Sheet */}
      <QRLabelSheet
        orderId={order._id}
        orderNumber={order.orderNumber}
        panels={panelLabels}
      />
    </div>
  );
}
```

Also need to update the QR labels page for static export compatibility. Create a generateStaticParams:

Add to the page or create a separate file. For static export with dynamic routes, we need the same pattern as Phase 07:

Actually, since this is an admin page and will be accessed dynamically, we need to handle it similar to the portal pages. Add dynamic route config:

**src/app/admin/orders/[id]/qr-labels/page.tsx:** (update)
```typescript
// Add at the top for static export compatibility
export const dynamicParams = false;

export function generateStaticParams() {
  // Placeholder for static export - real IDs loaded at runtime
  return [{ id: "__placeholder__" }];
}
```

Update the page to handle placeholder:

```typescript
// Near the top of the component
if (orderId === "__placeholder__") {
  return null;
}
```
  </action>
  <verify>Visit /admin/orders, expand an order, see Production Specs section with download buttons</verify>
  <done>SpecDownloader integrated into OrderCard, QR labels print page created</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Transformer works:
   - transformOrderToSpec converts order data to spec format
   - Cabinets, panels, hardware, edge banding all populated

2. PDF download works:
   - Click "Production Spec (PDF)" button
   - PDF downloads with all sections
   - File named {orderNumber}-production-spec.pdf

3. CSV downloads work:
   - Click "Panel Schedule (CSV)" - CSV downloads
   - Click "Hardware List (CSV)" - CSV downloads
   - Open CSVs in Excel/Sheets - data displays correctly

4. QR labels work:
   - Click "QR Labels (Print)" opens new page
   - QR codes render with panel info
   - Print button triggers browser print dialog

5. Build passes:
   - `npm run build` completes without errors
   - No "window is not defined" errors from PDF libs
</verification>

<success_criteria>
- PDF generates with header, cabinet schedule, panel schedule, edge banding, hardware list
- Panel CSV downloads with all panel columns
- Hardware CSV downloads with quantities and totals
- QR label page renders printable grid of codes
- All downloads use order number in filename
- Build passes without SSR errors
- Admin can access all downloads from expanded OrderCard
</success_criteria>

<output>
After completion, create `.planning/phases/08-production-integration---admin/08-05-SUMMARY.md`
</output>
