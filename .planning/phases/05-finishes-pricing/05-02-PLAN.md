---
phase: 05-finishes-pricing
plan: 02
type: execute
wave: 2
depends_on: ["05-01"]
files_modified:
  - src/hooks/usePricing.ts
  - src/components/pricing/PriceDisplay.tsx
  - src/components/pricing/PriceBreakdown.tsx
  - src/components/pricing/PriceStickyBar.tsx
autonomous: true

must_haves:
  truths:
    - "Pricing hook calculates totals from database and store"
    - "Prices display in AUD currency format"
    - "Hardware variance (±5%) is calculated and shown"
  artifacts:
    - path: "src/hooks/usePricing.ts"
      provides: "Centralized pricing calculation"
      exports: ["usePricing"]
      min_lines: 80
    - path: "src/components/pricing/PriceDisplay.tsx"
      provides: "Currency formatting component"
      exports: ["PriceDisplay"]
    - path: "src/components/pricing/PriceBreakdown.tsx"
      provides: "Itemized price breakdown"
      exports: ["PriceBreakdown"]
    - path: "src/components/pricing/PriceStickyBar.tsx"
      provides: "Sticky total bar for wizard"
      exports: ["PriceStickyBar"]
  key_links:
    - from: "src/hooks/usePricing.ts"
      to: "convex/_generated/api"
      via: "useQuery for pricing data"
      pattern: "useQuery\\(api\\.products"
    - from: "src/hooks/usePricing.ts"
      to: "src/stores/useCabinetStore.ts"
      via: "Zustand selector for config"
      pattern: "useCabinetStore"
    - from: "src/components/pricing/PriceBreakdown.tsx"
      to: "src/hooks/usePricing.ts"
      via: "hook consumption"
      pattern: "usePricing\\(\\)"
---

<objective>
Create the pricing calculation hook and display components.

Purpose: Build the centralized `usePricing` hook that queries Convex for pricing data, reads configuration from Zustand, calculates totals with category breakdown, and returns formatted values. Create reusable display components for showing prices throughout the wizard.

Output: usePricing hook, PriceDisplay, PriceBreakdown, PriceStickyBar components.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/05-finishes-pricing/05-RESEARCH.md
@.planning/phases/05-finishes-pricing/05-01-SUMMARY.md

@src/stores/useCabinetStore.ts
@src/types/configurator.ts
@convex/products/materials.ts
@convex/products/hardware.ts
@convex/products/modules.ts
@convex/doorProfiles.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create usePricing hook</name>
  <files>src/hooks/usePricing.ts</files>
  <action>
Create the centralized pricing calculation hook following the RESEARCH.md pattern:

```typescript
/**
 * usePricing hook
 * Phase 05: Finishes & Pricing
 *
 * Centralized pricing calculation that:
 * - Queries all pricing data from Convex (reactive)
 * - Reads configuration from Zustand store
 * - Calculates breakdown by category (all in cents)
 * - Returns formatted currency strings
 */

import { useMemo } from 'react'
import { useQuery } from 'convex/react'
import { useCabinetStore } from '@/stores/useCabinetStore'
import { api } from '../../convex/_generated/api'

interface PriceBreakdown {
  cabinets: number      // In cents
  material: number      // In cents
  hardware: number      // In cents
  doorProfile: number   // In cents
  addons: number        // In cents
  total: number         // In cents
}

interface FormattedBreakdown {
  cabinets: string
  material: string
  hardware: string
  doorProfile: string
  addons: string
  total: string
  hardwareVariance: string  // ±5% amount
}

export function usePricing() {
  // Reactive Convex queries
  const materials = useQuery(api.products.materials.list)
  const hardware = useQuery(api.products.hardware.list)
  const doorProfiles = useQuery(api.doorProfiles.list)
  const modules = useQuery(api.products.modules.list)

  // Subscribe only to config slice (not entire store)
  const config = useCabinetStore((state) => state.config)

  // Memoized formatter instance (en-AU, AUD)
  const formatter = useMemo(
    () => new Intl.NumberFormat('en-AU', {
      style: 'currency',
      currency: 'AUD',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }),
    []
  )

  // Calculate breakdown (memoized, recalculates only on dependency change)
  const breakdown = useMemo<PriceBreakdown>(() => {
    // Handle loading state - return zeros
    if (!materials || !hardware || !doorProfiles || !modules) {
      return { cabinets: 0, material: 0, hardware: 0, doorProfile: 0, addons: 0, total: 0 }
    }

    let cabinetsCost = 0
    let materialCost = 0
    let hardwareCost = 0
    let doorProfileCost = 0
    let addonsCost = 0

    // Calculate cabinet/module costs
    // Match module type to modules table by looking for matching category/type
    config.slots.forEach((slot) => {
      if (!slot.module) return

      // Find module by type - simplified matching
      // Module types in store: 'standard', 'sink-base', etc.
      // Modules in DB: 'MOD-BASE-600', 'MOD-BASE-SINK', etc.
      const moduleType = slot.module.type
      let matchedModule = modules.find((m) => {
        const codeLC = m.code.toLowerCase()
        // Map store module types to database module codes
        if (moduleType === 'standard' && codeLC.includes('base-600')) return true
        if (moduleType === 'sink-base' && codeLC.includes('sink')) return true
        if (moduleType === 'drawer-stack' && codeLC.includes('drawer')) return true
        if (moduleType === 'pull-out-pantry' && codeLC.includes('pantry')) return true
        if (moduleType === 'corner-base' && codeLC.includes('corner') && m.category === 'corner') return true
        if (moduleType === 'appliance-tower' && codeLC.includes('tall')) return true
        if (moduleType === 'open-shelving' && codeLC.includes('base-300')) return true
        if (moduleType === 'standard-overhead' && codeLC.includes('oh-600')) return true
        if (moduleType === 'glass-door' && codeLC.includes('oh-450')) return true
        if (moduleType === 'open-shelf' && codeLC.includes('oh-300')) return true
        if (moduleType === 'rangehood-space' && codeLC.includes('rangehood')) return true
        if (moduleType === 'lift-up-door' && codeLC.includes('oh-600')) return true
        return false
      })

      // Fallback: use average module price if no match
      if (!matchedModule) {
        matchedModule = modules.find((m) => m.code === 'MOD-BASE-600')
      }

      if (matchedModule) {
        cabinetsCost += matchedModule.pricePerUnit // Already in cents
      }
    })

    // Calculate material cost (flat price per selection)
    const selectedMaterial = materials.find((m) => m.code === config.finishes.material)
    if (selectedMaterial) {
      materialCost = selectedMaterial.pricePerUnit // Already in cents
    }

    // Calculate hardware cost
    const selectedHardware = hardware.find((h) => h.code === config.finishes.hardware)
    if (selectedHardware) {
      hardwareCost = selectedHardware.pricePerUnit // Already in cents
    }

    // Calculate door profile cost (price per door × module count)
    const selectedProfile = doorProfiles.find((p) => p.code === config.finishes.doorProfile)
    if (selectedProfile) {
      // Count modules that have doors (rough approximation: all modules)
      const doorCount = Array.from(config.slots.values()).filter(s => s.module).length
      doorProfileCost = selectedProfile.pricePerDoor * doorCount
    }

    // Add-ons: sum all addon prices per module (future enhancement)
    // For now, keep at 0 until add-ons UI is wired

    return {
      cabinets: cabinetsCost,
      material: materialCost,
      hardware: hardwareCost,
      doorProfile: doorProfileCost,
      addons: addonsCost,
      total: cabinetsCost + materialCost + hardwareCost + doorProfileCost + addonsCost,
    }
  }, [config, materials, hardware, doorProfiles, modules])

  // Format breakdown for display
  const formatted = useMemo<FormattedBreakdown>(() => {
    const hardwareVarianceAmount = Math.round((breakdown.hardware * 5) / 100)
    return {
      cabinets: formatter.format(breakdown.cabinets / 100),
      material: formatter.format(breakdown.material / 100),
      hardware: formatter.format(breakdown.hardware / 100),
      doorProfile: formatter.format(breakdown.doorProfile / 100),
      addons: formatter.format(breakdown.addons / 100),
      total: formatter.format(breakdown.total / 100),
      hardwareVariance: formatter.format(hardwareVarianceAmount / 100),
    }
  }, [breakdown, formatter])

  // Loading state
  const isLoading = !materials || !hardware || !doorProfiles || !modules

  // Helper function for ad-hoc formatting
  const formatPrice = (cents: number) => formatter.format(cents / 100)

  return {
    breakdown,      // Raw cents values
    formatted,      // Formatted AUD strings
    formatPrice,    // Helper for ad-hoc formatting
    isLoading,
  }
}
```

Important implementation notes:
1. Use Zustand selector `(state) => state.config` not entire store
2. Use `useMemo` for formatter and breakdown calculations
3. Return both raw cents and formatted strings
4. Calculate hardware variance (±5%) as per pricing decisions
5. Handle loading state gracefully (return zeros)
  </action>
  <verify>
Run TypeScript check: `npx tsc --noEmit`
Verify file exists and exports usePricing
Verify useMemo is used for calculations
  </verify>
  <done>usePricing hook exists, queries Convex, reads Zustand config, calculates breakdown in cents, returns formatted AUD strings.</done>
</task>

<task type="auto">
  <name>Task 2: Create pricing display components</name>
  <files>
    src/components/pricing/PriceDisplay.tsx
    src/components/pricing/PriceBreakdown.tsx
    src/components/pricing/PriceStickyBar.tsx
  </files>
  <action>
Create the pricing components directory and three components:

**1. PriceDisplay.tsx** - Single price with optional variance:
```typescript
/**
 * PriceDisplay component
 * Displays a single price value with optional variance indicator
 */

import { useMemo } from 'react'
import { cn } from '@/lib/utils'

interface PriceDisplayProps {
  cents: number
  label?: string
  className?: string
  showVariance?: boolean
  varianceCents?: number
  size?: 'sm' | 'md' | 'lg'
}

export function PriceDisplay({
  cents,
  label,
  className,
  showVariance = false,
  varianceCents = 0,
  size = 'md',
}: PriceDisplayProps) {
  const formatter = useMemo(
    () => new Intl.NumberFormat('en-AU', {
      style: 'currency',
      currency: 'AUD',
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }),
    []
  )

  const sizeClasses = {
    sm: 'text-sm',
    md: 'text-base',
    lg: 'text-lg',
  }

  return (
    <div className={cn('space-y-0.5', className)}>
      {label && (
        <span className="block text-sm text-zinc-600">{label}</span>
      )}
      <p className={cn('font-semibold text-zinc-900', sizeClasses[size])}>
        {formatter.format(cents / 100)}
        {showVariance && varianceCents > 0 && (
          <span className="text-sm font-normal text-zinc-500 ml-1">
            ±{formatter.format(varianceCents / 100)}
          </span>
        )}
      </p>
    </div>
  )
}
```

**2. PriceBreakdown.tsx** - Full itemized breakdown:
```typescript
/**
 * PriceBreakdown component
 * Displays itemized price breakdown with variance disclaimer
 */

import { usePricing } from '@/hooks/usePricing'

export function PriceBreakdown() {
  const { formatted, breakdown, isLoading } = usePricing()

  if (isLoading) {
    return <PriceBreakdownSkeleton />
  }

  return (
    <div className="p-4 bg-white border rounded-lg">
      <h3 className="font-medium mb-3">Price Breakdown</h3>

      <div className="space-y-2 text-sm">
        <div className="flex justify-between">
          <span className="text-zinc-600">Cabinets</span>
          <span className="font-medium">{formatted.cabinets}</span>
        </div>

        <div className="flex justify-between">
          <span className="text-zinc-600">Material</span>
          <span className="font-medium">{formatted.material}</span>
        </div>

        <div className="flex justify-between">
          <span className="text-zinc-600">Hardware</span>
          <span className="font-medium">
            {formatted.hardware}
            {breakdown.hardware > 0 && (
              <span className="text-xs text-zinc-500 ml-1">±5%</span>
            )}
          </span>
        </div>

        <div className="flex justify-between">
          <span className="text-zinc-600">Door Profile</span>
          <span className="font-medium">{formatted.doorProfile}</span>
        </div>

        {/* Total */}
        <div className="border-t pt-2 mt-2 flex justify-between font-semibold text-base">
          <span>Total</span>
          <span>{formatted.total}</span>
        </div>
      </div>

      {/* Variance disclaimer */}
      <div className="mt-4 p-3 bg-zinc-50 rounded text-xs text-zinc-600 space-y-1">
        <p>
          <strong>Important:</strong> This is an estimate only. Final price will be
          confirmed after site measure.
        </p>
        <p>
          Hardware pricing may vary ±{formatted.hardwareVariance} based on supplier
          availability.
        </p>
      </div>
    </div>
  )
}

function PriceBreakdownSkeleton() {
  return (
    <div className="p-4 bg-white border rounded-lg animate-pulse">
      <div className="h-5 bg-zinc-200 rounded w-32 mb-3" />
      <div className="space-y-2">
        {[1, 2, 3, 4].map((i) => (
          <div key={i} className="flex justify-between">
            <div className="h-4 bg-zinc-200 rounded w-20" />
            <div className="h-4 bg-zinc-200 rounded w-16" />
          </div>
        ))}
      </div>
    </div>
  )
}
```

**3. PriceStickyBar.tsx** - Sticky bar for wizard:
```typescript
/**
 * PriceStickyBar component
 * Sticky bottom bar showing live total price during configuration
 */

import { usePricing } from '@/hooks/usePricing'

export function PriceStickyBar() {
  const { formatted, isLoading } = usePricing()

  return (
    <div className="sticky bottom-0 left-0 right-0 bg-white border-t shadow-lg px-4 py-3 z-10">
      <div className="flex items-center justify-between max-w-lg mx-auto">
        <div>
          <span className="text-sm text-zinc-600">Estimated Total</span>
          {isLoading ? (
            <div className="h-6 w-24 bg-zinc-200 animate-pulse rounded mt-0.5" />
          ) : (
            <p className="text-lg font-semibold text-zinc-900">{formatted.total}</p>
          )}
        </div>
        <div className="text-xs text-zinc-500 text-right max-w-[140px]">
          Final price after site measure
        </div>
      </div>
    </div>
  )
}
```

Create the directory first: mkdir -p src/components/pricing
  </action>
  <verify>
Run TypeScript check: `npx tsc --noEmit`
Verify all three files exist in src/components/pricing/
Verify each file exports its named component
  </verify>
  <done>PriceDisplay, PriceBreakdown, PriceStickyBar components exist with proper AUD formatting and variance disclaimers.</done>
</task>

</tasks>

<verification>
1. TypeScript compiles without errors
2. usePricing hook returns { breakdown, formatted, formatPrice, isLoading }
3. PriceBreakdown renders loading skeleton when data loading
4. PriceBreakdown shows variance disclaimer
5. All prices formatted with Intl.NumberFormat (en-AU, AUD)
</verification>

<success_criteria>
- [ ] src/hooks/usePricing.ts exists and exports usePricing
- [ ] Hook queries Convex for materials, hardware, doorProfiles, modules
- [ ] Hook reads config from Zustand with selector
- [ ] Calculations use useMemo to prevent unnecessary recalculation
- [ ] All three pricing components created
- [ ] Components handle loading state with skeleton
- [ ] Variance disclaimer appears in PriceBreakdown
- [ ] TypeScript compiles successfully
</success_criteria>

<output>
After completion, create `.planning/phases/05-finishes-pricing/05-02-SUMMARY.md`
</output>
