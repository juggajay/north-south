---
phase: 04-3d-configurator-core
plan: 04
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/components/wizard/WizardShell.tsx
  - src/components/wizard/StepIndicator.tsx
  - src/components/wizard/StepNavigation.tsx
  - src/components/wizard/StepDimensions.tsx
  - src/components/wizard/DimensionSync.tsx
  - src/components/ui/slider-control.tsx
autonomous: true

must_haves:
  truths:
    - "Wizard shell displays 4 steps with progress indicator"
    - "Next/Back buttons navigate between steps"
    - "Step 1 shows dimension sliders"
    - "Validation prevents advancing without valid dimensions"
  artifacts:
    - path: "src/components/wizard/WizardShell.tsx"
      provides: "Wizard container with step content"
      exports: ["WizardShell"]
    - path: "src/components/wizard/StepIndicator.tsx"
      provides: "Step progress indicator"
      exports: ["StepIndicator"]
    - path: "src/components/wizard/StepNavigation.tsx"
      provides: "Next/Back navigation buttons"
      exports: ["StepNavigation"]
    - path: "src/components/wizard/StepDimensions.tsx"
      provides: "Step 1 dimension controls"
      exports: ["StepDimensions"]
    - path: "src/components/wizard/DimensionSync.tsx"
      provides: "3D viewport sync inside Canvas context"
      exports: ["DimensionSync"]
  key_links:
    - from: "src/components/wizard/WizardShell.tsx"
      to: "src/stores/useWizardStore.ts"
      via: "useWizardStore hook"
      pattern: "useWizardStore\\("
    - from: "src/components/wizard/StepDimensions.tsx"
      to: "src/stores/useCabinetStore.ts"
      via: "dimension setters"
      pattern: "setDimension\\("
    - from: "src/components/wizard/DimensionSync.tsx"
      to: "@react-three/fiber"
      via: "useThree inside Canvas"
      pattern: "useThree\\("
---

<objective>
Create the 4-step wizard navigation shell and Step 1 (Dimensions) with sliders.

Purpose: Establishes the wizard flow that users navigate through to configure their cabinet.
Output: Wizard shell with step indicator, navigation buttons, and dimension controls for Step 1.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-3d-configurator-core/04-CONTEXT.md
@src/stores/useWizardStore.ts
@src/stores/useCabinetStore.ts
@src/components/ui/slider.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create StepIndicator and StepNavigation components</name>
  <files>
    src/components/wizard/StepIndicator.tsx
    src/components/wizard/StepNavigation.tsx
  </files>
  <action>
Create `src/components/wizard/StepIndicator.tsx`:

Per CONTEXT.md: Step indicator placement is Claude's discretion. Place at top for always-visible progress.

**IMPORTANT per CONTEXT.md "unlocking progression":** Steps unlock once visited, then are freely revisitable.
This means step indicator circles ARE clickable for visited steps - users can jump directly to any
previously visited step. This is the intended behavior from the user's explicit decision.

Display 4 steps: Dimensions, Layout, Finishes, Review
- Show current step highlighted
- Show completed steps with checkmark
- Show locked steps as disabled (not yet visited)
- **Visited steps are CLICKABLE** - clicking jumps to that step

```typescript
import { useWizardStore } from '@/stores/useWizardStore'
import { Check } from 'lucide-react'
import { cn } from '@/lib/utils'

const STEPS = [
  { id: 0, name: 'Dimensions', shortName: '1' },
  { id: 1, name: 'Layout', shortName: '2' },
  { id: 2, name: 'Finishes', shortName: '3' },
  { id: 3, name: 'Review', shortName: '4' },
]

export function StepIndicator() {
  const { currentStep, visitedSteps, goToStep } = useWizardStore()

  const handleStepClick = (stepId: number) => {
    // Per CONTEXT.md: "later steps unlock once visited, then freely revisitable"
    // Visited steps are clickable for direct navigation
    if (visitedSteps.has(stepId)) {
      goToStep(stepId)
    }
  }

  return (
    <div className="flex items-center justify-between px-4 py-3 bg-white border-b">
      {STEPS.map((step, index) => {
        const isActive = currentStep === step.id
        const isCompleted = visitedSteps.has(step.id) && currentStep > step.id
        const isAccessible = visitedSteps.has(step.id)

        return (
          <div key={step.id} className="flex items-center">
            {index > 0 && (
              <div className={cn(
                "w-8 h-0.5 mx-1",
                isAccessible ? "bg-zinc-900" : "bg-zinc-200"
              )} />
            )}
            <div className="flex flex-col items-center">
              {/* Step circle - clickable if visited (per unlocking progression) */}
              <button
                type="button"
                onClick={() => handleStepClick(step.id)}
                disabled={!isAccessible}
                className={cn(
                  "w-8 h-8 rounded-full flex items-center justify-center text-sm font-medium transition-colors",
                  isActive && "bg-zinc-900 text-white",
                  isCompleted && "bg-zinc-900 text-white",
                  !isActive && !isCompleted && isAccessible && "border-2 border-zinc-900 text-zinc-900 hover:bg-zinc-100 cursor-pointer",
                  !isAccessible && "border-2 border-zinc-300 text-zinc-300 cursor-not-allowed"
                )}
              >
                {isCompleted ? <Check className="w-4 h-4" /> : step.shortName}
              </button>
              <span className={cn(
                "text-xs mt-1",
                isActive ? "text-zinc-900 font-medium" : "text-zinc-500"
              )}>
                {step.name}
              </span>
            </div>
          </div>
        )
      })}
    </div>
  )
}
```

Create `src/components/wizard/StepNavigation.tsx`:

Per CONTEXT.md: Next/Back buttons for navigation (no swipe between steps).
- Back button disabled on Step 1
- Next button disabled if current step validation fails
- On Step 4 (Review), Next becomes "Submit" (future integration)

```typescript
import { Button } from '@/components/ui/button'
import { useWizardStore } from '@/stores/useWizardStore'
import { ChevronLeft, ChevronRight } from 'lucide-react'

export function StepNavigation() {
  const { currentStep, canProceed, nextStep, prevStep } = useWizardStore()

  const isFirstStep = currentStep === 0
  const isLastStep = currentStep === 3
  const canGoNext = canProceed(currentStep)

  return (
    <div className="flex items-center justify-between px-4 py-3 bg-white border-t">
      <Button
        variant="outline"
        onClick={prevStep}
        disabled={isFirstStep}
        className="min-w-[100px]"
      >
        <ChevronLeft className="w-4 h-4 mr-1" />
        Back
      </Button>

      <Button
        onClick={nextStep}
        disabled={!canGoNext}
        className="min-w-[100px]"
      >
        {isLastStep ? 'Submit' : 'Next'}
        {!isLastStep && <ChevronRight className="w-4 h-4 ml-1" />}
      </Button>
    </div>
  )
}
```
  </action>
  <verify>
Components render without errors.
StepIndicator shows 4 steps with correct styling.
Visited step circles are clickable (test by visiting Step 2, going back, then clicking Step 2 circle).
Unvisited step circles are NOT clickable (greyed out, cursor: not-allowed).
StepNavigation buttons enable/disable correctly based on step.
  </verify>
  <done>
StepIndicator and StepNavigation components created with proper state binding. Step indicator circles correctly implement unlocking progression (clickable when visited).
  </done>
</task>

<task type="auto">
  <name>Task 2: Create touch-friendly slider control component</name>
  <files>
    src/components/ui/slider-control.tsx
  </files>
  <action>
Create `src/components/ui/slider-control.tsx`:

A touch-friendly dimension slider with:
- Label (e.g., "Width")
- Current value display with unit (e.g., "2400mm")
- Slider with visible track and thumb
- Plus/minus stepper buttons for precise adjustment
- Optional min/max labels

Per requirements:
- Width: 1200-3600mm in 100mm increments
- Depth: discrete options (400, 500, 560, 600, 650mm)
- Height: 1800-2400mm in 100mm increments

```typescript
import { Slider } from '@/components/ui/slider'
import { Button } from '@/components/ui/button'
import { Minus, Plus } from 'lucide-react'
import { cn } from '@/lib/utils'

interface SliderControlProps {
  label: string
  value: number
  min: number
  max: number
  step: number
  unit?: string
  onChange: (value: number) => void
}

export function SliderControl({
  label,
  value,
  min,
  max,
  step,
  unit = 'mm',
  onChange,
}: SliderControlProps) {
  const handleDecrement = () => {
    const newValue = Math.max(min, value - step)
    onChange(newValue)
  }

  const handleIncrement = () => {
    const newValue = Math.min(max, value + step)
    onChange(newValue)
  }

  return (
    <div className="space-y-3">
      <div className="flex items-center justify-between">
        <span className="text-sm font-medium text-zinc-700">{label}</span>
        <span className="text-sm font-semibold text-zinc-900">
          {value}{unit}
        </span>
      </div>

      <div className="flex items-center gap-3">
        <Button
          variant="outline"
          size="icon"
          className="h-10 w-10 shrink-0"
          onClick={handleDecrement}
          disabled={value <= min}
        >
          <Minus className="h-4 w-4" />
        </Button>

        <Slider
          value={[value]}
          min={min}
          max={max}
          step={step}
          onValueChange={([newValue]) => onChange(newValue)}
          className="flex-1"
        />

        <Button
          variant="outline"
          size="icon"
          className="h-10 w-10 shrink-0"
          onClick={handleIncrement}
          disabled={value >= max}
        >
          <Plus className="h-4 w-4" />
        </Button>
      </div>

      <div className="flex justify-between text-xs text-zinc-500">
        <span>{min}{unit}</span>
        <span>{max}{unit}</span>
      </div>
    </div>
  )
}

interface DepthSelectorProps {
  value: number
  options: number[]
  onChange: (value: number) => void
}

export function DepthSelector({ value, options, onChange }: DepthSelectorProps) {
  return (
    <div className="space-y-3">
      <span className="text-sm font-medium text-zinc-700">Depth</span>
      <div className="grid grid-cols-5 gap-2">
        {options.map((option) => (
          <button
            key={option}
            onClick={() => onChange(option)}
            className={cn(
              "py-2 px-3 rounded-md text-sm font-medium border",
              value === option
                ? "bg-zinc-900 text-white border-zinc-900"
                : "bg-white text-zinc-700 border-zinc-300 hover:border-zinc-400"
            )}
          >
            {option}
          </button>
        ))}
      </div>
      <span className="text-xs text-zinc-500">mm</span>
    </div>
  )
}
```
  </action>
  <verify>
Render SliderControl with test values.
Drag slider updates value.
Plus/minus buttons increment/decrement by step.
Buttons disable at min/max.
DepthSelector shows discrete options and highlights selection.
  </verify>
  <done>
Touch-friendly SliderControl and DepthSelector components created.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create StepDimensions, DimensionSync, and WizardShell</name>
  <files>
    src/components/wizard/StepDimensions.tsx
    src/components/wizard/DimensionSync.tsx
    src/components/wizard/WizardShell.tsx
  </files>
  <action>
**IMPORTANT: useThree() can ONLY be called inside Canvas context.**

Create `src/components/wizard/DimensionSync.tsx`:

This component lives INSIDE the Canvas and syncs dimension changes to trigger 3D re-renders.
It subscribes to useCabinetStore and calls invalidate() when dimensions change.

```typescript
import { useEffect, useRef } from 'react'
import { useThree } from '@react-three/fiber'
import { useCabinetStore } from '@/stores/useCabinetStore'

/**
 * DimensionSync - Must be rendered INSIDE Canvas context
 *
 * Subscribes to dimension changes in useCabinetStore and invalidates
 * the Three.js renderer to trigger re-render. This keeps useThree()
 * properly within Canvas context while allowing dimension controls
 * outside Canvas to trigger updates.
 */
export function DimensionSync() {
  const { invalidate } = useThree()
  const prevDimensionsRef = useRef(useCabinetStore.getState().dimensions)

  useEffect(() => {
    // Subscribe to store changes
    const unsubscribe = useCabinetStore.subscribe((state) => {
      const newDimensions = state.dimensions
      const prev = prevDimensionsRef.current

      // Check if dimensions actually changed
      if (
        newDimensions.width !== prev.width ||
        newDimensions.height !== prev.height ||
        newDimensions.depth !== prev.depth
      ) {
        prevDimensionsRef.current = newDimensions
        invalidate() // Trigger 3D re-render
      }
    })

    return () => unsubscribe()
  }, [invalidate])

  // This component renders nothing - it's just for the subscription
  return null
}
```

Create `src/components/wizard/StepDimensions.tsx`:

Step 1: Dimension controls per requirements.
**NOTE: NO useThree() here - this component is OUTSIDE Canvas.**
3D updates are handled by DimensionSync inside Canvas.

```typescript
import { SliderControl, DepthSelector } from '@/components/ui/slider-control'
import { useCabinetStore } from '@/stores/useCabinetStore'

const DEPTH_OPTIONS = [400, 500, 560, 600, 650]

interface StepDimensionsProps {
  aiEstimate?: { width: number; depth: number; height: number }
}

export function StepDimensions({ aiEstimate }: StepDimensionsProps) {
  const dimensions = useCabinetStore((state) => state.dimensions)
  const setDimension = useCabinetStore((state) => state.setDimension)

  // No useThree() here! DimensionSync inside Canvas handles invalidation.

  return (
    <div className="space-y-6 p-4">
      <div>
        <h2 className="text-lg font-semibold text-zinc-900">Set Dimensions</h2>
        <p className="text-sm text-zinc-500">
          {aiEstimate
            ? 'We estimated these dimensions from your photo. Adjust as needed.'
            : 'Enter your cabinet dimensions.'}
        </p>
      </div>

      <SliderControl
        label="Width"
        value={dimensions.width}
        min={1200}
        max={3600}
        step={100}
        onChange={(v) => setDimension('width', v)}
      />

      <DepthSelector
        value={dimensions.depth}
        options={DEPTH_OPTIONS}
        onChange={(v) => setDimension('depth', v)}
      />

      <SliderControl
        label="Height"
        value={dimensions.height}
        min={1800}
        max={2400}
        step={100}
        onChange={(v) => setDimension('height', v)}
      />

      {aiEstimate && (
        <p className="text-xs text-zinc-400 text-center">
          AI estimated: {aiEstimate.width} x {aiEstimate.depth} x {aiEstimate.height}mm
        </p>
      )}
    </div>
  )
}
```

Create `src/components/wizard/WizardShell.tsx`:

Main wizard container that:
- Shows StepIndicator at top
- Renders current step content in middle (40% of screen per CFG-003)
- Shows StepNavigation at bottom
- Sticky bottom bar with live price (placeholder for now)

```typescript
import { useWizardStore } from '@/stores/useWizardStore'
import { StepIndicator } from './StepIndicator'
import { StepNavigation } from './StepNavigation'
import { StepDimensions } from './StepDimensions'
// Future: import { StepLayout, StepFinishes, StepReview } from './...'

interface WizardShellProps {
  aiEstimate?: { width: number; depth: number; height: number }
}

export function WizardShell({ aiEstimate }: WizardShellProps) {
  const currentStep = useWizardStore((state) => state.currentStep)

  const renderStepContent = () => {
    switch (currentStep) {
      case 0:
        return <StepDimensions aiEstimate={aiEstimate} />
      case 1:
        return <div className="p-4 text-zinc-500">Layout step (Plan 05)</div>
      case 2:
        return <div className="p-4 text-zinc-500">Finishes step (Plan 07)</div>
      case 3:
        return <div className="p-4 text-zinc-500">Review step (Plan 07)</div>
      default:
        return null
    }
  }

  return (
    <div className="flex flex-col h-full bg-zinc-50">
      <StepIndicator />

      <div className="flex-1 overflow-y-auto">
        {renderStepContent()}
      </div>

      {/* Sticky price bar placeholder */}
      <div className="px-4 py-2 bg-white border-t">
        <div className="flex items-center justify-between">
          <span className="text-sm text-zinc-500">Estimated total</span>
          <span className="text-lg font-semibold text-zinc-900">$--,---</span>
        </div>
      </div>

      <StepNavigation />
    </div>
  )
}
```

**IMPORTANT:** The Canvas3D component must include DimensionSync:

```typescript
// In Canvas3D.tsx or ConfiguratorPage.tsx:
<Canvas3D>
  <DimensionSync />  {/* Add this inside Canvas! */}
  <CabinetModel />
  <CameraController />
</Canvas3D>
```

This pattern keeps useThree() inside Canvas context where it belongs, while allowing
StepDimensions (outside Canvas) to update dimensions via the store.
  </action>
  <verify>
Render WizardShell in a test page.
StepIndicator shows Dimensions as active.
Sliders work and update values.
Add DimensionSync inside Canvas - verify 3D updates when sliders move.
Next button disabled until valid dimensions set.
Clicking Next advances to Step 2 placeholder.
Back returns to Step 1.
  </verify>
  <done>
WizardShell with StepDimensions fully functional. DimensionSync component handles 3D invalidation inside Canvas context. Navigation between steps works with validation.
  </done>
</task>

</tasks>

<verification>
- StepIndicator shows 4 steps with correct state
- Step indicator circles are CLICKABLE for visited steps (unlocking progression)
- StepNavigation enables/disables buttons correctly
- SliderControl is touch-friendly with stepper buttons
- StepDimensions updates store (NO useThree call - that's in DimensionSync)
- DimensionSync lives inside Canvas and triggers 3D updates
- Validation prevents Next without valid dimensions
- WizardShell renders all components together
</verification>

<success_criteria>
- 4-step wizard UI complete with navigation
- Step 1 (Dimensions) fully functional
- useThree() properly contained inside Canvas context (via DimensionSync)
- Validation working per requirements
- Touch-friendly controls
</success_criteria>

<output>
After completion, create `.planning/phases/04-3d-configurator-core/04-04-SUMMARY.md`
</output>
