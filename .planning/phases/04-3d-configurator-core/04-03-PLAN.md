---
phase: 04-3d-configurator-core
plan: 03
type: execute
wave: 2
depends_on: ["04-01"]
files_modified:
  - src/components/configurator/CabinetModel.tsx
  - src/components/configurator/CabinetFrame.tsx
  - src/components/configurator/CameraController.tsx
  - src/lib/hooks/useGestures.ts
autonomous: true

must_haves:
  truths:
    - "3D cabinet frame renders and updates with dimensions"
    - "Camera can be rotated, zoomed, and panned via touch"
    - "Reset camera button appears after user moves camera"
  artifacts:
    - path: "src/components/configurator/CabinetModel.tsx"
      provides: "Cabinet container with frame and slots"
      exports: ["CabinetModel"]
    - path: "src/components/configurator/CabinetFrame.tsx"
      provides: "Cabinet frame geometry that scales with dimensions"
      exports: ["CabinetFrame"]
    - path: "src/components/configurator/CameraController.tsx"
      provides: "OrbitControls wrapper with reset button"
      exports: ["CameraController"]
    - path: "src/lib/hooks/useGestures.ts"
      provides: "Touch gesture bindings"
      exports: ["useGestures"]
  key_links:
    - from: "src/components/configurator/CabinetFrame.tsx"
      to: "src/stores/useCabinetStore.ts"
      via: "getState() in useFrame"
      pattern: "useCabinetStore\\.getState\\(\\)"
---

<objective>
Create the 3D cabinet model and camera controls with touch gestures.

Purpose: Delivers the core 3D viewport interaction - users see a cabinet that responds to dimension changes and can manipulate the camera with touch gestures.
Output: CabinetModel with scaling frame, CameraController with reset button, touch gesture system.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-3d-configurator-core/04-RESEARCH.md
@.planning/phases/04-3d-configurator-core/04-CONTEXT.md
@src/stores/useCabinetStore.ts
@src/components/configurator/Canvas3D.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CabinetFrame component that scales with dimensions</name>
  <files>
    src/components/configurator/CabinetFrame.tsx
  </files>
  <action>
Create `src/components/configurator/CabinetFrame.tsx`:

This component renders the basic cabinet frame (outer box) that scales based on store dimensions.

Key implementation:
- Use useFrame to read dimensions from store (NOT reactive subscription - per RESEARCH.md pitfall)
- Convert mm to Three.js units (1 unit = 100mm for reasonable scale)
- Render as a wireframe box showing cabinet boundaries
- Include subtle fill mesh with low opacity for depth perception
- Use damp() from three/src/math/MathUtils for smooth dimension transitions

```typescript
import { useRef } from 'react'
import { useFrame } from '@react-three/fiber'
import { Edges, Box } from '@react-three/drei'
import { damp } from 'three/src/math/MathUtils'
import * as THREE from 'three'
import { useCabinetStore } from '@/stores/useCabinetStore'

const MM_TO_UNITS = 0.001 // 1mm = 0.001 units (so 2400mm = 2.4 units)

export function CabinetFrame() {
  const meshRef = useRef<THREE.Mesh>(null)

  useFrame((state, delta) => {
    if (!meshRef.current) return

    const { dimensions } = useCabinetStore.getState()

    // Convert dimensions to scene units
    const targetWidth = dimensions.width * MM_TO_UNITS
    const targetHeight = dimensions.height * MM_TO_UNITS
    const targetDepth = dimensions.depth * MM_TO_UNITS

    // Smooth interpolation for dimension changes
    meshRef.current.scale.x = damp(meshRef.current.scale.x, targetWidth, 4, delta)
    meshRef.current.scale.y = damp(meshRef.current.scale.y, targetHeight, 4, delta)
    meshRef.current.scale.z = damp(meshRef.current.scale.z, targetDepth, 4, delta)

    // Center vertically (cabinet sits on floor)
    meshRef.current.position.y = meshRef.current.scale.y / 2
  })

  return (
    <mesh ref={meshRef}>
      <boxGeometry args={[1, 1, 1]} />
      <meshStandardMaterial
        color="#e5e5e5"
        transparent
        opacity={0.1}
      />
      <Edges color="#737373" lineWidth={1} />
    </mesh>
  )
}
```

Also add a floor plane for grounding:
- Mesh with planeGeometry rotated -90 degrees on X
- Subtle grid or shadow receiver
  </action>
  <verify>
Import CabinetFrame into Canvas3D test.
Change dimensions in store: `useCabinetStore.getState().setDimension('width', 3000)`
Frame smoothly scales to new dimensions.
  </verify>
  <done>
CabinetFrame renders and scales smoothly with dimension changes from store.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create CameraController with OrbitControls and reset button</name>
  <files>
    src/components/configurator/CameraController.tsx
  </files>
  <action>
Create `src/components/configurator/CameraController.tsx`:

Per CONTEXT.md decisions:
- Default camera: 3/4 view (slight angle showing depth and side)
- Reset camera button appears after user moves camera (subtle, positioned appropriately)
- Rotation limits: front hemisphere (Claude's discretion per CONTEXT.md)

Implementation:
```typescript
import { useRef, useState, useCallback } from 'react'
import { useThree, useFrame } from '@react-three/fiber'
import { OrbitControls, Html } from '@react-three/drei'
import type { OrbitControls as OrbitControlsImpl } from 'three-stdlib'
import * as THREE from 'three'

// Default 3/4 view camera position
const DEFAULT_POSITION = new THREE.Vector3(3, 2, 4)
const DEFAULT_TARGET = new THREE.Vector3(0, 1, 0) // Look at cabinet center

export function CameraController() {
  const controlsRef = useRef<OrbitControlsImpl>(null)
  const [hasMovedCamera, setHasMovedCamera] = useState(false)
  const { camera, invalidate } = useThree()

  const handleChange = useCallback(() => {
    // Check if camera has moved from default position
    if (!hasMovedCamera) {
      const distance = camera.position.distanceTo(DEFAULT_POSITION)
      if (distance > 0.1) {
        setHasMovedCamera(true)
      }
    }
    invalidate() // Trigger render (frameloop='demand')
  }, [hasMovedCamera, camera, invalidate])

  const resetCamera = useCallback(() => {
    if (!controlsRef.current) return

    camera.position.copy(DEFAULT_POSITION)
    controlsRef.current.target.copy(DEFAULT_TARGET)
    controlsRef.current.update()
    setHasMovedCamera(false)
    invalidate()
  }, [camera, invalidate])

  return (
    <>
      <OrbitControls
        ref={controlsRef}
        makeDefault
        enableDamping
        dampingFactor={0.05}
        // Limit rotation to front hemisphere (avoid seeing back of cabinet)
        minPolarAngle={Math.PI * 0.1}
        maxPolarAngle={Math.PI * 0.6}
        minAzimuthAngle={-Math.PI * 0.5}
        maxAzimuthAngle={Math.PI * 0.5}
        // Zoom limits
        minDistance={2}
        maxDistance={8}
        // Touch settings
        touches={{
          ONE: THREE.TOUCH.ROTATE,
          TWO: THREE.TOUCH.DOLLY_PAN
        }}
        onChange={handleChange}
      />

      {hasMovedCamera && (
        <Html
          position={[0, 0, 0]}
          center
          style={{
            position: 'absolute',
            top: '16px',
            right: '16px',
            pointerEvents: 'auto'
          }}
        >
          <button
            onClick={resetCamera}
            className="px-3 py-1.5 bg-white/90 rounded-full text-xs font-medium shadow-sm hover:bg-white"
          >
            Reset View
          </button>
        </Html>
      )}
    </>
  )
}
```

Notes:
- OrbitControls from drei handles touch gestures internally
- onChange triggers invalidate() for on-demand rendering
- Reset button uses Html from drei for DOM overlay
  </action>
  <verify>
Add CameraController to Canvas3D.
Touch/mouse drag rotates the camera.
Pinch/scroll zooms.
Reset button appears after moving camera.
Reset button restores 3/4 view.
  </verify>
  <done>
CameraController with OrbitControls, rotation limits, and reset button working.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create CabinetModel container and integrate components</name>
  <files>
    src/components/configurator/CabinetModel.tsx
    src/lib/hooks/useGestures.ts
  </files>
  <action>
Create `src/lib/hooks/useGestures.ts`:
Simple hook that wraps @use-gesture/react for any additional gesture handling beyond OrbitControls.
For now, export a minimal hook that could be extended later:

```typescript
import { useGesture } from '@use-gesture/react'

export function useCabinetGestures(onTap?: (point: THREE.Vector3) => void) {
  // OrbitControls handles rotate/zoom/pan
  // This hook is for tap-to-select and other custom gestures

  return useGesture({
    onClick: ({ event }) => {
      // Will be used for slot/door tap selection
      if (onTap && event.point) {
        onTap(event.point)
      }
    }
  })
}
```

Create `src/components/configurator/CabinetModel.tsx`:
Container component that composes CabinetFrame and will later include slots/modules.

```typescript
import { CabinetFrame } from './CabinetFrame'

interface CabinetModelProps {
  onSlotTap?: (slotId: string) => void
}

export function CabinetModel({ onSlotTap }: CabinetModelProps) {
  return (
    <group>
      <CabinetFrame />
      {/* Slots will be added in Plan 05 */}
      {/* Floor plane for grounding */}
      <mesh rotation={[-Math.PI / 2, 0, 0]} position={[0, 0, 0]} receiveShadow>
        <planeGeometry args={[10, 10]} />
        <meshStandardMaterial color="#f5f5f5" />
      </mesh>
    </group>
  )
}
```

Update Canvas3D to include CabinetModel and CameraController as default scene:

```typescript
// In Canvas3D.tsx, add optional includeDefaultScene prop
// If true, render CabinetModel and CameraController
```
  </action>
  <verify>
Render full configurator scene:
```tsx
<Canvas3D className="h-[60vh]">
  <CabinetModel />
  <CameraController />
</Canvas3D>
```
- Cabinet frame visible with 3/4 view
- Camera controls work (rotate, zoom, pan)
- Reset button appears/works
- Dimensions can be changed and cabinet updates
  </verify>
  <done>
CabinetModel container created. All 3D scene components integrated. Touch gestures working via OrbitControls.
  </done>
</task>

</tasks>

<verification>
- Cabinet frame renders at correct dimensions
- Dimension changes animate smoothly
- Camera starts at 3/4 view angle
- Touch drag rotates camera
- Pinch zooms
- Two-finger drag pans
- Reset button appears after camera movement
- Reset restores default view
- frameloop="demand" works (no continuous rendering when idle)
</verification>

<success_criteria>
- 3D cabinet visible with correct proportions
- Camera controls fully functional on touch devices
- Performance maintained (on-demand rendering)
- Reset camera feature working
</success_criteria>

<output>
After completion, create `.planning/phases/04-3d-configurator-core/04-03-SUMMARY.md`
</output>
