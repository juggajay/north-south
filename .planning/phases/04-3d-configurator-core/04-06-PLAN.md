---
phase: 04-3d-configurator-core
plan: 06
type: execute
wave: 3
depends_on: ["04-03", "04-05"]
files_modified:
  - src/components/configurator/modules/BaseModule.tsx
  - src/components/configurator/modules/OverheadModule.tsx
  - src/components/configurator/modules/ModuleFactory.tsx
  - src/components/configurator/CabinetDoor.tsx
  - src/components/wizard/InteriorOptions.tsx
autonomous: true

must_haves:
  truths:
    - "All 12 module types render in 3D"
    - "Doors can be tapped to open/close"
    - "Interior options configurable via bottom sheet"
  artifacts:
    - path: "src/components/configurator/modules/BaseModule.tsx"
      provides: "Base cabinet module 3D components"
      exports: ["StandardBase", "SinkBase", "DrawerStack", "PullOutPantry", "CornerBase", "ApplianceTower", "OpenShelving"]
    - path: "src/components/configurator/modules/OverheadModule.tsx"
      provides: "Overhead cabinet module 3D components"
      exports: ["StandardOverhead", "GlassDoor", "OpenShelf", "RangehoodSpace", "LiftUpDoor"]
    - path: "src/components/configurator/modules/ModuleFactory.tsx"
      provides: "Factory function to render module by type"
      exports: ["renderModule"]
    - path: "src/components/configurator/CabinetDoor.tsx"
      provides: "Animated door with tap-to-toggle"
      exports: ["CabinetDoor"]
  key_links:
    - from: "src/components/configurator/modules/ModuleFactory.tsx"
      to: "src/components/configurator/ModuleSlot.tsx"
      via: "renderModule call"
      pattern: "renderModule\\("
---

<objective>
Create 3D module components for all 12 cabinet types with animated doors and interior options.

Purpose: Brings the configurator to life with actual 3D representations of each module type.
Output: 12 module components, animated door system, interior options configuration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-3d-configurator-core/04-CONTEXT.md
@.planning/phases/04-3d-configurator-core/04-RESEARCH.md
@src/types/configurator.ts
@src/components/configurator/ModuleSlot.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CabinetDoor with tap-to-toggle animation</name>
  <files>
    src/components/configurator/CabinetDoor.tsx
  </files>
  <action>
Create `src/components/configurator/CabinetDoor.tsx`:

Per CONTEXT.md: Tap to toggle open/close individual cabinet doors.
Per RESEARCH.md: Use damp() in useFrame for smooth animation, NOT setState.

```typescript
import { useRef, useState, useCallback } from 'react'
import { useFrame, useThree } from '@react-three/fiber'
import { damp } from 'three/src/math/MathUtils'
import * as THREE from 'three'

interface CabinetDoorProps {
  width: number // in scene units
  height: number
  depth: number // door thickness
  position: [number, number, number]
  hinge: 'left' | 'right'
  material?: THREE.Material
  openAngle?: number // radians, default Math.PI * 0.6
}

export function CabinetDoor({
  width,
  height,
  depth = 0.02,
  position,
  hinge,
  material,
  openAngle = Math.PI * 0.6,
}: CabinetDoorProps) {
  const meshRef = useRef<THREE.Mesh>(null)
  const pivotRef = useRef<THREE.Group>(null)
  const [isOpen, setIsOpen] = useState(false)
  const { invalidate } = useThree()

  // Calculate pivot offset based on hinge side
  const pivotOffset = hinge === 'left' ? -width / 2 : width / 2

  useFrame((state, delta) => {
    if (!pivotRef.current) return

    const targetRotation = isOpen
      ? (hinge === 'left' ? -openAngle : openAngle)
      : 0

    // Smooth interpolation
    pivotRef.current.rotation.y = damp(
      pivotRef.current.rotation.y,
      targetRotation,
      4, // damping factor
      delta
    )

    // Keep invalidating while animating
    if (Math.abs(pivotRef.current.rotation.y - targetRotation) > 0.01) {
      invalidate()
    }
  })

  const handleClick = useCallback((event: THREE.Event) => {
    event.stopPropagation()
    setIsOpen((prev) => !prev)
    invalidate()
  }, [invalidate])

  const handlePointerOver = useCallback(() => {
    document.body.style.cursor = 'pointer'
  }, [])

  const handlePointerOut = useCallback(() => {
    document.body.style.cursor = 'default'
  }, [])

  // Default material if none provided
  const doorMaterial = material || new THREE.MeshStandardMaterial({
    color: '#d4d4d4',
    roughness: 0.4,
    metalness: 0.1,
  })

  return (
    <group position={position}>
      {/* Pivot point at hinge */}
      <group ref={pivotRef} position={[pivotOffset, 0, 0]}>
        <mesh
          ref={meshRef}
          position={[-pivotOffset, 0, depth / 2]}
          onClick={handleClick}
          onPointerOver={handlePointerOver}
          onPointerOut={handlePointerOut}
        >
          <boxGeometry args={[width, height, depth]} />
          <primitive object={doorMaterial} attach="material" />
        </mesh>

        {/* Door handle */}
        <mesh
          position={[
            hinge === 'left' ? width * 0.35 : -width * 0.35,
            0,
            depth + 0.01
          ]}
        >
          <cylinderGeometry args={[0.01, 0.01, 0.08, 8]} />
          <meshStandardMaterial color="#737373" metalness={0.8} roughness={0.2} />
        </mesh>
      </group>
    </group>
  )
}
```

Also create drawer and lift-up variants:

```typescript
// Drawer - pulls out on Z axis
export function CabinetDrawer({ ... }) {
  // Similar pattern but slides on Z instead of rotates on Y
}

// Lift-up door - rotates on X axis at top
export function LiftUpDoorPanel({ ... }) {
  // Pivot at top, rotates upward
}
```
  </action>
  <verify>
Render CabinetDoor in isolation test.
Tap door - it animates open.
Tap again - it animates closed.
Animation is smooth (uses damp).
Handle visible and positioned correctly.
  </verify>
  <done>
CabinetDoor with tap-to-toggle smooth animation working for all door types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create all 12 module type components</name>
  <files>
    src/components/configurator/modules/BaseModule.tsx
    src/components/configurator/modules/OverheadModule.tsx
    src/components/configurator/modules/ModuleFactory.tsx
  </files>
  <action>
Create `src/components/configurator/modules/BaseModule.tsx`:

7 base cabinet module components. Each module is a procedural 3D model (not GLTF yet).

```typescript
import { useMemo } from 'react'
import * as THREE from 'three'
import { CabinetDoor, CabinetDrawer } from '../CabinetDoor'
import type { ModuleConfig } from '@/types/configurator'

const MM_TO_UNITS = 0.001

interface BaseModuleProps {
  config: ModuleConfig
  width: number // mm
  height?: number // mm, default 800
  depth?: number // mm, default 560
}

// Shared cabinet body (carcass without doors)
function CabinetCarcass({ width, height, depth }: { width: number; height: number; depth: number }) {
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS
  const thickness = 0.018 // 18mm panels

  return (
    <group>
      {/* Back panel */}
      <mesh position={[0, h/2, -d/2 + thickness/2]}>
        <boxGeometry args={[w - thickness*2, h, thickness]} />
        <meshStandardMaterial color="#e5e5e5" />
      </mesh>
      {/* Left side */}
      <mesh position={[-w/2 + thickness/2, h/2, 0]}>
        <boxGeometry args={[thickness, h, d]} />
        <meshStandardMaterial color="#d4d4d4" />
      </mesh>
      {/* Right side */}
      <mesh position={[w/2 - thickness/2, h/2, 0]}>
        <boxGeometry args={[thickness, h, d]} />
        <meshStandardMaterial color="#d4d4d4" />
      </mesh>
      {/* Bottom */}
      <mesh position={[0, thickness/2, 0]}>
        <boxGeometry args={[w - thickness*2, thickness, d - thickness]} />
        <meshStandardMaterial color="#d4d4d4" />
      </mesh>
    </group>
  )
}

// 1. Standard Base - door with shelf
export function StandardBase({ config, width, height = 800, depth = 560 }: BaseModuleProps) {
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS

  return (
    <group>
      <CabinetCarcass width={width} height={height} depth={depth} />
      <CabinetDoor
        width={w - 0.004}
        height={h - 0.004}
        depth={0.018}
        position={[0, h/2, d/2]}
        hinge="left"
      />
      {/* Interior shelf */}
      {config.interiorOptions?.shelfCount && (
        <mesh position={[0, h * 0.5, 0]}>
          <boxGeometry args={[w - 0.04, 0.018, d - 0.04]} />
          <meshStandardMaterial color="#e5e5e5" />
        </mesh>
      )}
    </group>
  )
}

// 2. Sink Base - open for plumbing
export function SinkBase({ config, width, height = 800, depth = 560 }: BaseModuleProps) {
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS

  return (
    <group>
      <CabinetCarcass width={width} height={height} depth={depth} />
      {/* Double doors */}
      <CabinetDoor
        width={(w - 0.006) / 2}
        height={h - 0.004}
        depth={0.018}
        position={[-w/4, h/2, d/2]}
        hinge="left"
      />
      <CabinetDoor
        width={(w - 0.006) / 2}
        height={h - 0.004}
        depth={0.018}
        position={[w/4, h/2, d/2]}
        hinge="right"
      />
    </group>
  )
}

// 3. Drawer Stack - 3-4 drawers
export function DrawerStack({ config, width, height = 800, depth = 560 }: BaseModuleProps) {
  const drawerCount = config.interiorOptions?.drawerCount || 4
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const drawerH = h / drawerCount

  return (
    <group>
      <CabinetCarcass width={width} height={height} depth={depth} />
      {Array.from({ length: drawerCount }).map((_, i) => (
        <CabinetDrawer
          key={i}
          width={w - 0.004}
          height={drawerH - 0.004}
          position={[0, drawerH * (i + 0.5), 0]}
        />
      ))}
    </group>
  )
}

// 4. Pull-out Pantry - tall with pull-out
export function PullOutPantry({ config, width, height = 2100, depth = 560 }: BaseModuleProps) {
  // Tall cabinet with internal pull-out
  return (
    <group>
      <CabinetCarcass width={width} height={height} depth={depth} />
      {/* Simplified: just show as tall cabinet with door for now */}
      <CabinetDoor
        width={width * MM_TO_UNITS - 0.004}
        height={height * MM_TO_UNITS - 0.004}
        depth={0.018}
        position={[0, height * MM_TO_UNITS / 2, depth * MM_TO_UNITS / 2]}
        hinge="left"
      />
    </group>
  )
}

// 5. Corner Base
export function CornerBase({ config, width, height = 800, depth = 560 }: BaseModuleProps) {
  // L-shaped corner unit
  return (
    <group>
      <CabinetCarcass width={width} height={height} depth={depth} />
      {/* Angled door for corner access */}
      <CabinetDoor
        width={width * MM_TO_UNITS * 0.7}
        height={height * MM_TO_UNITS - 0.004}
        depth={0.018}
        position={[0, height * MM_TO_UNITS / 2, depth * MM_TO_UNITS / 2]}
        hinge="left"
      />
    </group>
  )
}

// 6. Appliance Tower
export function ApplianceTower({ config, width, height = 2100, depth = 560 }: BaseModuleProps) {
  return (
    <group>
      <CabinetCarcass width={width} height={height} depth={depth} />
      {/* Opening for appliance */}
      <mesh position={[0, height * MM_TO_UNITS * 0.4, depth * MM_TO_UNITS * 0.4]}>
        <boxGeometry args={[width * MM_TO_UNITS * 0.8, height * MM_TO_UNITS * 0.4, 0.02]} />
        <meshStandardMaterial color="#27272a" />
      </mesh>
    </group>
  )
}

// 7. Open Shelving
export function OpenShelving({ config, width, height = 800, depth = 560 }: BaseModuleProps) {
  const shelfCount = config.interiorOptions?.shelfCount || 2
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS

  return (
    <group>
      <CabinetCarcass width={width} height={height} depth={depth} />
      {/* No doors, just shelves */}
      {Array.from({ length: shelfCount }).map((_, i) => (
        <mesh key={i} position={[0, h * ((i + 1) / (shelfCount + 1)), 0]}>
          <boxGeometry args={[w - 0.04, 0.018, d - 0.04]} />
          <meshStandardMaterial color="#e5e5e5" />
        </mesh>
      ))}
    </group>
  )
}
```

Create `src/components/configurator/modules/OverheadModule.tsx`:

5 overhead cabinet modules (similar pattern, shorter height).

```typescript
// Similar structure to BaseModule.tsx
// StandardOverhead, GlassDoor, OpenShelf, RangehoodSpace, LiftUpDoor
```

Create `src/components/configurator/modules/ModuleFactory.tsx`:

```typescript
import type { ModuleConfig, ModuleType } from '@/types/configurator'
import {
  StandardBase, SinkBase, DrawerStack, PullOutPantry,
  CornerBase, ApplianceTower, OpenShelving
} from './BaseModule'
import {
  StandardOverhead, GlassDoor, OpenShelf,
  RangehoodSpace, LiftUpDoor
} from './OverheadModule'

interface ModuleFactoryProps {
  config: ModuleConfig
  width: number
  slotType: 'base' | 'overhead'
}

export function renderModule({ config, width, slotType }: ModuleFactoryProps) {
  const height = slotType === 'base' ? 800 : 600

  switch (config.type) {
    // Base modules
    case 'standard':
      return <StandardBase config={config} width={width} height={height} />
    case 'sink-base':
      return <SinkBase config={config} width={width} height={height} />
    case 'drawer-stack':
      return <DrawerStack config={config} width={width} height={height} />
    case 'pull-out-pantry':
      return <PullOutPantry config={config} width={width} />
    case 'corner-base':
      return <CornerBase config={config} width={width} height={height} />
    case 'appliance-tower':
      return <ApplianceTower config={config} width={width} />
    case 'open-shelving':
      return <OpenShelving config={config} width={width} height={height} />

    // Overhead modules
    case 'standard-overhead':
      return <StandardOverhead config={config} width={width} height={height} />
    case 'glass-door':
      return <GlassDoor config={config} width={width} height={height} />
    case 'open-shelf':
      return <OpenShelf config={config} width={width} height={height} />
    case 'rangehood-space':
      return <RangehoodSpace config={config} width={width} height={height} />
    case 'lift-up-door':
      return <LiftUpDoor config={config} width={width} height={height} />

    default:
      return null
  }
}
```

Update ModuleSlot to use renderModule for filled slots.
  </action>
  <verify>
Place each module type via ModulePicker.
All 12 types render distinct 3D geometry.
Doors on applicable modules can be opened/closed.
Drawers slide out when tapped.
  </verify>
  <done>
All 12 module types render as 3D components with interactive doors.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create InteriorOptions bottom sheet for module customization</name>
  <files>
    src/components/wizard/InteriorOptions.tsx
  </files>
  <action>
Create `src/components/wizard/InteriorOptions.tsx`:

Per CONTEXT.md: Interior configuration flow is Claude's discretion.
Using nested bottom sheet that appears after module is placed.

Options per module type:
- Standard: shelf count (1-3)
- DrawerStack: drawer count (3-4), dividers (yes/no)
- OpenShelving: shelf count (1-4)
- Others: type-specific options

Also handle add-ons (LED strips, pull-out bins) per requirements.

```typescript
import Sheet from 'react-modal-sheet'
import { useCabinetStore } from '@/stores/useCabinetStore'
import type { ModuleConfig } from '@/types/configurator'
import { SliderControl } from '@/components/ui/slider-control'
import { Switch } from '@/components/ui/switch'
import { Label } from '@/components/ui/label'

// Add-ons available for any module
const ADDONS = [
  { id: 'led-strip', name: 'LED Strip', price: 85 },
  { id: 'pull-out-bin', name: 'Pull-out Bin', price: 120 },
  { id: 'drawer-divider', name: 'Drawer Dividers', price: 45 },
]

interface InteriorOptionsProps {
  isOpen: boolean
  slotId: string | null
  onClose: () => void
}

export function InteriorOptions({ isOpen, slotId, onClose }: InteriorOptionsProps) {
  const slots = useCabinetStore((state) => state.slots)
  const setModule = useCabinetStore((state) => state.setModule)

  const module = slotId ? slots.get(slotId) : null

  if (!module) return null

  const updateInterior = (key: string, value: any) => {
    if (!slotId) return
    setModule(slotId, {
      ...module,
      interiorOptions: {
        ...module.interiorOptions,
        [key]: value,
      },
    })
  }

  const toggleAddon = (addonId: string) => {
    if (!slotId) return
    const currentAddons = module.addons || []
    const newAddons = currentAddons.includes(addonId)
      ? currentAddons.filter((id) => id !== addonId)
      : [...currentAddons, addonId]

    setModule(slotId, { ...module, addons: newAddons })
  }

  // Render options based on module type
  const renderTypeOptions = () => {
    switch (module.type) {
      case 'standard':
      case 'open-shelving':
        return (
          <div className="space-y-4">
            <h4 className="font-medium">Shelves</h4>
            <SliderControl
              label="Number of Shelves"
              value={module.interiorOptions?.shelfCount || 1}
              min={1}
              max={4}
              step={1}
              unit=""
              onChange={(v) => updateInterior('shelfCount', v)}
            />
          </div>
        )

      case 'drawer-stack':
        return (
          <div className="space-y-4">
            <h4 className="font-medium">Drawers</h4>
            <SliderControl
              label="Number of Drawers"
              value={module.interiorOptions?.drawerCount || 4}
              min={3}
              max={5}
              step={1}
              unit=""
              onChange={(v) => updateInterior('drawerCount', v)}
            />
            <div className="flex items-center justify-between">
              <Label>Drawer Dividers</Label>
              <Switch
                checked={module.interiorOptions?.hasDividers || false}
                onCheckedChange={(v) => updateInterior('hasDividers', v)}
              />
            </div>
          </div>
        )

      default:
        return (
          <p className="text-sm text-zinc-500">
            No additional options for this module type.
          </p>
        )
    }
  }

  return (
    <Sheet
      isOpen={isOpen}
      onClose={onClose}
      snapPoints={[450, 0]}
      initialSnap={0}
    >
      <Sheet.Container>
        <Sheet.Header />
        <Sheet.Content>
          <div className="px-4 pb-8 space-y-6">
            <div>
              <h3 className="text-lg font-semibold">Interior Options</h3>
              <p className="text-sm text-zinc-500">{module.type}</p>
            </div>

            {renderTypeOptions()}

            {/* Add-ons section */}
            <div className="space-y-3">
              <h4 className="font-medium">Add-ons</h4>
              {ADDONS.map((addon) => (
                <div
                  key={addon.id}
                  className="flex items-center justify-between p-3 border rounded-lg"
                >
                  <div>
                    <p className="font-medium text-sm">{addon.name}</p>
                    <p className="text-xs text-zinc-500">+${addon.price}</p>
                  </div>
                  <Switch
                    checked={module.addons?.includes(addon.id) || false}
                    onCheckedChange={() => toggleAddon(addon.id)}
                  />
                </div>
              ))}
            </div>

            <button
              onClick={onClose}
              className="w-full py-3 bg-zinc-900 text-white rounded-lg font-medium"
            >
              Done
            </button>
          </div>
        </Sheet.Content>
      </Sheet.Container>
      <Sheet.Backdrop onTap={onClose} />
    </Sheet>
  )
}
```

Integrate InteriorOptions into StepLayout - show after module selection.
  </action>
  <verify>
Select a module with interior options (Standard, DrawerStack).
Interior options sheet opens automatically or via "Configure" button.
Changing shelf count updates store.
Adding add-ons updates store.
3D module updates to reflect new shelf count.
  </verify>
  <done>
InteriorOptions bottom sheet complete. Module interiors and add-ons configurable.
  </done>
</task>

</tasks>

<verification>
- All 12 module types render distinct 3D geometry
- Doors animate open/close on tap
- CabinetDoor animation is smooth (damp in useFrame)
- Interior options affect 3D render (shelf count visible)
- Add-ons can be toggled per module
- ModuleFactory correctly maps type to component
</verification>

<success_criteria>
- Complete 3D representation of all module types
- Interactive doors with smooth animation
- Interior customization working
- Add-ons selectable
</success_criteria>

<output>
After completion, create `.planning/phases/04-3d-configurator-core/04-06-SUMMARY.md`
</output>
