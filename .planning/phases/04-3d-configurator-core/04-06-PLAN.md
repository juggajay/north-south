---
phase: 04-3d-configurator-core
plan: 06
type: execute
wave: 3
depends_on: ["04-03", "04-05"]
files_modified:
  - src/components/configurator/modules/BaseModule.tsx
  - src/components/configurator/modules/OverheadModule.tsx
  - src/components/configurator/modules/ModuleFactory.tsx
  - src/components/configurator/CabinetDoor.tsx
  - src/components/wizard/InteriorOptions.tsx
autonomous: true

must_haves:
  truths:
    - "All 12 module types render in 3D"
    - "Doors can be tapped to open/close"
    - "Interior options configurable via bottom sheet"
  artifacts:
    - path: "src/components/configurator/modules/BaseModule.tsx"
      provides: "Base cabinet module 3D components"
      exports: ["StandardBase", "SinkBase", "DrawerStack", "PullOutPantry", "CornerBase", "ApplianceTower", "OpenShelving"]
    - path: "src/components/configurator/modules/OverheadModule.tsx"
      provides: "Overhead cabinet module 3D components"
      exports: ["StandardOverhead", "GlassDoor", "OpenShelf", "RangehoodSpace", "LiftUpDoor"]
    - path: "src/components/configurator/modules/ModuleFactory.tsx"
      provides: "Factory function to render module by type"
      exports: ["renderModule"]
    - path: "src/components/configurator/CabinetDoor.tsx"
      provides: "Animated door with tap-to-toggle"
      exports: ["CabinetDoor", "CabinetDrawer", "LiftUpDoorPanel"]
  key_links:
    - from: "src/components/configurator/modules/ModuleFactory.tsx"
      to: "src/components/configurator/ModuleSlot.tsx"
      via: "renderModule call"
      pattern: "renderModule\\("
---

<objective>
Create 3D module components for all 12 cabinet types with animated doors and interior options.

Purpose: Brings the configurator to life with actual 3D representations of each module type.
Output: 12 module components, animated door system, interior options configuration.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-3d-configurator-core/04-CONTEXT.md
@.planning/phases/04-3d-configurator-core/04-RESEARCH.md
@src/types/configurator.ts
@src/components/configurator/ModuleSlot.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CabinetDoor, CabinetDrawer, and LiftUpDoorPanel with animations</name>
  <files>
    src/components/configurator/CabinetDoor.tsx
  </files>
  <action>
Create `src/components/configurator/CabinetDoor.tsx`:

Per CONTEXT.md: Tap to toggle open/close individual cabinet doors.
Per RESEARCH.md: Use damp() in useFrame for smooth animation, NOT setState.

This file contains THREE door types:
1. CabinetDoor - Standard hinged door (Y-axis rotation)
2. CabinetDrawer - Drawer that slides out (Z-axis translation)
3. LiftUpDoorPanel - Lift-up door (X-axis rotation at top)

```typescript
import { useRef, useState, useCallback } from 'react'
import { useFrame, useThree } from '@react-three/fiber'
import { damp } from 'three/src/math/MathUtils'
import * as THREE from 'three'

// ============================================
// 1. CABINET DOOR - Standard hinged door
// ============================================
interface CabinetDoorProps {
  width: number // in scene units
  height: number
  depth?: number // door thickness
  position: [number, number, number]
  hinge: 'left' | 'right'
  material?: THREE.Material
  openAngle?: number // radians, default Math.PI * 0.6
}

export function CabinetDoor({
  width,
  height,
  depth = 0.018,
  position,
  hinge,
  material,
  openAngle = Math.PI * 0.6,
}: CabinetDoorProps) {
  const pivotRef = useRef<THREE.Group>(null)
  const [isOpen, setIsOpen] = useState(false)
  const { invalidate } = useThree()

  // Calculate pivot offset based on hinge side
  const pivotOffset = hinge === 'left' ? -width / 2 : width / 2

  useFrame((state, delta) => {
    if (!pivotRef.current) return

    const targetRotation = isOpen
      ? (hinge === 'left' ? -openAngle : openAngle)
      : 0

    // Smooth interpolation
    pivotRef.current.rotation.y = damp(
      pivotRef.current.rotation.y,
      targetRotation,
      4, // damping factor
      delta
    )

    // Keep invalidating while animating
    if (Math.abs(pivotRef.current.rotation.y - targetRotation) > 0.01) {
      invalidate()
    }
  })

  const handleClick = useCallback((event: THREE.Event) => {
    event.stopPropagation()
    setIsOpen((prev) => !prev)
    invalidate()
  }, [invalidate])

  const handlePointerOver = useCallback(() => {
    document.body.style.cursor = 'pointer'
  }, [])

  const handlePointerOut = useCallback(() => {
    document.body.style.cursor = 'default'
  }, [])

  // Default material if none provided
  const doorMaterial = material || new THREE.MeshStandardMaterial({
    color: '#d4d4d4',
    roughness: 0.4,
    metalness: 0.1,
  })

  return (
    <group position={position}>
      {/* Pivot point at hinge */}
      <group ref={pivotRef} position={[pivotOffset, 0, 0]}>
        <mesh
          position={[-pivotOffset, 0, depth / 2]}
          onClick={handleClick}
          onPointerOver={handlePointerOver}
          onPointerOut={handlePointerOut}
        >
          <boxGeometry args={[width, height, depth]} />
          <primitive object={doorMaterial} attach="material" />
        </mesh>

        {/* Door handle */}
        <mesh
          position={[
            hinge === 'left' ? width * 0.35 : -width * 0.35,
            0,
            depth + 0.01
          ]}
          rotation={[Math.PI / 2, 0, 0]}
        >
          <cylinderGeometry args={[0.008, 0.008, 0.06, 8]} />
          <meshStandardMaterial color="#737373" metalness={0.8} roughness={0.2} />
        </mesh>
      </group>
    </group>
  )
}

// ============================================
// 2. CABINET DRAWER - Slides out on Z-axis
// ============================================
interface CabinetDrawerProps {
  width: number // scene units
  height: number
  depth?: number // how deep the drawer is
  position: [number, number, number]
  slideDistance?: number // how far it slides out
  material?: THREE.Material
}

export function CabinetDrawer({
  width,
  height,
  depth = 0.4,
  position,
  slideDistance = 0.35,
  material,
}: CabinetDrawerProps) {
  const groupRef = useRef<THREE.Group>(null)
  const [isOpen, setIsOpen] = useState(false)
  const { invalidate } = useThree()

  useFrame((state, delta) => {
    if (!groupRef.current) return

    const targetZ = isOpen ? slideDistance : 0

    // Smooth slide animation on Z axis
    groupRef.current.position.z = damp(
      groupRef.current.position.z,
      targetZ,
      4,
      delta
    )

    // Keep invalidating while animating
    if (Math.abs(groupRef.current.position.z - targetZ) > 0.01) {
      invalidate()
    }
  })

  const handleClick = useCallback((event: THREE.Event) => {
    event.stopPropagation()
    setIsOpen((prev) => !prev)
    invalidate()
  }, [invalidate])

  const handlePointerOver = useCallback(() => {
    document.body.style.cursor = 'pointer'
  }, [])

  const handlePointerOut = useCallback(() => {
    document.body.style.cursor = 'default'
  }, [])

  const drawerMaterial = material || new THREE.MeshStandardMaterial({
    color: '#d4d4d4',
    roughness: 0.4,
    metalness: 0.1,
  })

  const frontThickness = 0.018

  return (
    <group position={position}>
      <group ref={groupRef}>
        {/* Drawer front panel (the visible face) */}
        <mesh
          position={[0, 0, depth / 2 + frontThickness / 2]}
          onClick={handleClick}
          onPointerOver={handlePointerOver}
          onPointerOut={handlePointerOut}
        >
          <boxGeometry args={[width, height, frontThickness]} />
          <primitive object={drawerMaterial} attach="material" />
        </mesh>

        {/* Drawer box (the container) */}
        <mesh position={[0, 0, 0]}>
          <boxGeometry args={[width - 0.01, height - 0.02, depth]} />
          <meshStandardMaterial color="#e5e5e5" />
        </mesh>

        {/* Handle */}
        <mesh
          position={[0, 0, depth / 2 + frontThickness + 0.01]}
          rotation={[Math.PI / 2, 0, 0]}
        >
          <cylinderGeometry args={[0.008, 0.008, width * 0.3, 8]} />
          <meshStandardMaterial color="#737373" metalness={0.8} roughness={0.2} />
        </mesh>
      </group>
    </group>
  )
}

// ============================================
// 3. LIFT-UP DOOR PANEL - Rotates up on X-axis
// ============================================
interface LiftUpDoorPanelProps {
  width: number
  height: number
  depth?: number
  position: [number, number, number]
  material?: THREE.Material
  openAngle?: number // radians, default -Math.PI * 0.4 (lifts up)
}

export function LiftUpDoorPanel({
  width,
  height,
  depth = 0.018,
  position,
  material,
  openAngle = -Math.PI * 0.4, // Negative to rotate upward
}: LiftUpDoorPanelProps) {
  const pivotRef = useRef<THREE.Group>(null)
  const [isOpen, setIsOpen] = useState(false)
  const { invalidate } = useThree()

  // Pivot is at the TOP of the door
  const pivotOffsetY = height / 2

  useFrame((state, delta) => {
    if (!pivotRef.current) return

    const targetRotation = isOpen ? openAngle : 0

    // Smooth rotation on X axis (lifts up)
    pivotRef.current.rotation.x = damp(
      pivotRef.current.rotation.x,
      targetRotation,
      4,
      delta
    )

    // Keep invalidating while animating
    if (Math.abs(pivotRef.current.rotation.x - targetRotation) > 0.01) {
      invalidate()
    }
  })

  const handleClick = useCallback((event: THREE.Event) => {
    event.stopPropagation()
    setIsOpen((prev) => !prev)
    invalidate()
  }, [invalidate])

  const handlePointerOver = useCallback(() => {
    document.body.style.cursor = 'pointer'
  }, [])

  const handlePointerOut = useCallback(() => {
    document.body.style.cursor = 'default'
  }, [])

  const doorMaterial = material || new THREE.MeshStandardMaterial({
    color: '#d4d4d4',
    roughness: 0.4,
    metalness: 0.1,
  })

  return (
    <group position={position}>
      {/* Pivot point at top of door */}
      <group ref={pivotRef} position={[0, pivotOffsetY, 0]}>
        <mesh
          position={[0, -pivotOffsetY, depth / 2]}
          onClick={handleClick}
          onPointerOver={handlePointerOver}
          onPointerOut={handlePointerOut}
        >
          <boxGeometry args={[width, height, depth]} />
          <primitive object={doorMaterial} attach="material" />
        </mesh>

        {/* Handle at bottom of door */}
        <mesh
          position={[0, -height + 0.03, depth + 0.01]}
          rotation={[Math.PI / 2, 0, 0]}
        >
          <cylinderGeometry args={[0.008, 0.008, width * 0.3, 8]} />
          <meshStandardMaterial color="#737373" metalness={0.8} roughness={0.2} />
        </mesh>
      </group>
    </group>
  )
}
```
  </action>
  <verify>
Render CabinetDoor in isolation test - tap opens/closes with smooth Y-axis rotation.
Render CabinetDrawer - tap slides drawer out on Z-axis, tap again slides back.
Render LiftUpDoorPanel - tap rotates door upward on X-axis.
All animations are smooth (using damp, not instant).
Handles visible and positioned correctly for each type.
  </verify>
  <done>
CabinetDoor, CabinetDrawer, and LiftUpDoorPanel with tap-to-toggle smooth animations for all door types.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create all 12 module type components</name>
  <files>
    src/components/configurator/modules/BaseModule.tsx
    src/components/configurator/modules/OverheadModule.tsx
    src/components/configurator/modules/ModuleFactory.tsx
  </files>
  <action>
Create `src/components/configurator/modules/BaseModule.tsx`:

7 base cabinet module components. Each module is a procedural 3D model.

```typescript
import * as THREE from 'three'
import { CabinetDoor, CabinetDrawer } from '../CabinetDoor'
import type { ModuleConfig } from '@/types/configurator'

const MM_TO_UNITS = 0.001

interface BaseModuleProps {
  config: ModuleConfig
  width: number // mm
  height?: number // mm, default 800
  depth?: number // mm, default 560
}

// Shared cabinet body (carcass without doors)
function CabinetCarcass({ width, height, depth }: { width: number; height: number; depth: number }) {
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS
  const thickness = 0.018 // 18mm panels

  return (
    <group>
      {/* Back panel */}
      <mesh position={[0, h/2, -d/2 + thickness/2]}>
        <boxGeometry args={[w - thickness*2, h, thickness]} />
        <meshStandardMaterial color="#e5e5e5" />
      </mesh>
      {/* Left side */}
      <mesh position={[-w/2 + thickness/2, h/2, 0]}>
        <boxGeometry args={[thickness, h, d]} />
        <meshStandardMaterial color="#d4d4d4" />
      </mesh>
      {/* Right side */}
      <mesh position={[w/2 - thickness/2, h/2, 0]}>
        <boxGeometry args={[thickness, h, d]} />
        <meshStandardMaterial color="#d4d4d4" />
      </mesh>
      {/* Bottom */}
      <mesh position={[0, thickness/2, 0]}>
        <boxGeometry args={[w - thickness*2, thickness, d - thickness]} />
        <meshStandardMaterial color="#d4d4d4" />
      </mesh>
    </group>
  )
}

// 1. Standard Base - door with shelf
export function StandardBase({ config, width, height = 800, depth = 560 }: BaseModuleProps) {
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS

  const shelfCount = config.interiorOptions?.shelfCount || 1

  return (
    <group>
      <CabinetCarcass width={width} height={height} depth={depth} />
      <CabinetDoor
        width={w - 0.004}
        height={h - 0.004}
        depth={0.018}
        position={[0, h/2, d/2]}
        hinge="left"
      />
      {/* Interior shelves */}
      {Array.from({ length: shelfCount }).map((_, i) => (
        <mesh key={i} position={[0, h * ((i + 1) / (shelfCount + 1)), 0]}>
          <boxGeometry args={[w - 0.04, 0.018, d - 0.04]} />
          <meshStandardMaterial color="#e5e5e5" />
        </mesh>
      ))}
    </group>
  )
}

// 2. Sink Base - open for plumbing, double doors
export function SinkBase({ config, width, height = 800, depth = 560 }: BaseModuleProps) {
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS
  const doorWidth = (w - 0.006) / 2

  return (
    <group>
      <CabinetCarcass width={width} height={height} depth={depth} />
      {/* Double doors */}
      <CabinetDoor
        width={doorWidth}
        height={h - 0.004}
        depth={0.018}
        position={[-doorWidth/2 - 0.001, h/2, d/2]}
        hinge="left"
      />
      <CabinetDoor
        width={doorWidth}
        height={h - 0.004}
        depth={0.018}
        position={[doorWidth/2 + 0.001, h/2, d/2]}
        hinge="right"
      />
      {/* No internal shelf - open for plumbing */}
    </group>
  )
}

// 3. Drawer Stack - 3-5 stacked drawers
export function DrawerStack({ config, width, height = 800, depth = 560 }: BaseModuleProps) {
  const drawerCount = config.interiorOptions?.drawerCount || 4
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS
  const drawerH = h / drawerCount
  const drawerDepth = d * 0.85 // Drawer doesn't go full depth

  return (
    <group>
      <CabinetCarcass width={width} height={height} depth={depth} />
      {Array.from({ length: drawerCount }).map((_, i) => (
        <CabinetDrawer
          key={i}
          width={w - 0.006}
          height={drawerH - 0.006}
          depth={drawerDepth}
          position={[0, drawerH * i + drawerH/2, 0]}
          slideDistance={d * 0.6}
        />
      ))}
    </group>
  )
}

// 4. Pull-out Pantry - tall with internal pull-out shelving
export function PullOutPantry({ config, width, height = 2100, depth = 560 }: BaseModuleProps) {
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS

  return (
    <group>
      <CabinetCarcass width={width} height={height} depth={depth} />
      {/* Tall door */}
      <CabinetDoor
        width={w - 0.004}
        height={h - 0.004}
        depth={0.018}
        position={[0, h/2, d/2]}
        hinge="left"
      />
      {/* Internal pull-out basket indicators (simplified) */}
      {Array.from({ length: 5 }).map((_, i) => (
        <mesh key={i} position={[0, h * 0.15 + (h * 0.7 * i / 5), 0]}>
          <boxGeometry args={[w - 0.06, 0.01, d - 0.08]} />
          <meshStandardMaterial color="#a3a3a3" wireframe />
        </mesh>
      ))}
    </group>
  )
}

// 5. Corner Base - L-shaped corner unit
export function CornerBase({ config, width, height = 800, depth = 560 }: BaseModuleProps) {
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS
  const thickness = 0.018

  return (
    <group>
      {/* L-shaped carcass */}
      <mesh position={[-w/4, h/2, -d/4]}>
        <boxGeometry args={[w/2, h, d/2]} />
        <meshStandardMaterial color="#d4d4d4" />
      </mesh>
      <mesh position={[w/4, h/2, d/4]}>
        <boxGeometry args={[w/2, h, d/2]} />
        <meshStandardMaterial color="#d4d4d4" />
      </mesh>
      {/* Angled door for corner access */}
      <CabinetDoor
        width={w * 0.6}
        height={h - 0.004}
        depth={0.018}
        position={[0, h/2, d/2]}
        hinge="left"
      />
    </group>
  )
}

// 6. Appliance Tower - tall cabinet with appliance opening
export function ApplianceTower({ config, width, height = 2100, depth = 560 }: BaseModuleProps) {
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS
  const applianceH = h * 0.4 // 40% for appliance opening
  const applianceY = h * 0.3 // Position from bottom

  return (
    <group>
      <CabinetCarcass width={width} height={height} depth={depth} />
      {/* Top door (above appliance) */}
      <CabinetDoor
        width={w - 0.004}
        height={h * 0.25}
        depth={0.018}
        position={[0, h * 0.85, d/2]}
        hinge="left"
      />
      {/* Appliance opening - just a dark rectangle */}
      <mesh position={[0, applianceY + applianceH/2, d * 0.4]}>
        <boxGeometry args={[w * 0.85, applianceH, 0.02]} />
        <meshStandardMaterial color="#27272a" />
      </mesh>
      {/* Bottom drawer */}
      <CabinetDrawer
        width={w - 0.006}
        height={h * 0.15}
        depth={d * 0.85}
        position={[0, h * 0.08, 0]}
        slideDistance={d * 0.6}
      />
    </group>
  )
}

// 7. Open Shelving - no doors, just shelves
export function OpenShelving({ config, width, height = 800, depth = 560 }: BaseModuleProps) {
  const shelfCount = config.interiorOptions?.shelfCount || 2
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS

  return (
    <group>
      <CabinetCarcass width={width} height={height} depth={depth} />
      {/* No doors - just visible shelves */}
      {Array.from({ length: shelfCount }).map((_, i) => (
        <mesh key={i} position={[0, h * ((i + 1) / (shelfCount + 1)), 0]}>
          <boxGeometry args={[w - 0.04, 0.018, d - 0.04]} />
          <meshStandardMaterial color="#e5e5e5" />
        </mesh>
      ))}
    </group>
  )
}
```

Create `src/components/configurator/modules/OverheadModule.tsx`:

5 overhead cabinet modules.

```typescript
import * as THREE from 'three'
import { CabinetDoor, LiftUpDoorPanel } from '../CabinetDoor'
import type { ModuleConfig } from '@/types/configurator'

const MM_TO_UNITS = 0.001

interface OverheadModuleProps {
  config: ModuleConfig
  width: number // mm
  height?: number // mm, default 600 for overheads
  depth?: number // mm, default 350 for overheads
}

// Shared overhead cabinet carcass
function OverheadCarcass({ width, height, depth }: { width: number; height: number; depth: number }) {
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS
  const thickness = 0.018

  return (
    <group>
      {/* Back panel */}
      <mesh position={[0, h/2, -d/2 + thickness/2]}>
        <boxGeometry args={[w - thickness*2, h, thickness]} />
        <meshStandardMaterial color="#e5e5e5" />
      </mesh>
      {/* Left side */}
      <mesh position={[-w/2 + thickness/2, h/2, 0]}>
        <boxGeometry args={[thickness, h, d]} />
        <meshStandardMaterial color="#d4d4d4" />
      </mesh>
      {/* Right side */}
      <mesh position={[w/2 - thickness/2, h/2, 0]}>
        <boxGeometry args={[thickness, h, d]} />
        <meshStandardMaterial color="#d4d4d4" />
      </mesh>
      {/* Top */}
      <mesh position={[0, h - thickness/2, 0]}>
        <boxGeometry args={[w - thickness*2, thickness, d - thickness]} />
        <meshStandardMaterial color="#d4d4d4" />
      </mesh>
      {/* Bottom */}
      <mesh position={[0, thickness/2, 0]}>
        <boxGeometry args={[w - thickness*2, thickness, d - thickness]} />
        <meshStandardMaterial color="#d4d4d4" />
      </mesh>
    </group>
  )
}

// 1. Standard Overhead - single door with shelf
export function StandardOverhead({ config, width, height = 600, depth = 350 }: OverheadModuleProps) {
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS
  const shelfCount = config.interiorOptions?.shelfCount || 1

  return (
    <group>
      <OverheadCarcass width={width} height={height} depth={depth} />
      <CabinetDoor
        width={w - 0.004}
        height={h - 0.004}
        depth={0.018}
        position={[0, h/2, d/2]}
        hinge="left"
      />
      {/* Interior shelf */}
      {Array.from({ length: shelfCount }).map((_, i) => (
        <mesh key={i} position={[0, h * ((i + 1) / (shelfCount + 1)), 0]}>
          <boxGeometry args={[w - 0.04, 0.018, d - 0.04]} />
          <meshStandardMaterial color="#e5e5e5" />
        </mesh>
      ))}
    </group>
  )
}

// 2. Glass Door - transparent/frosted glass door
export function GlassDoor({ config, width, height = 600, depth = 350 }: OverheadModuleProps) {
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS
  const shelfCount = config.interiorOptions?.shelfCount || 1

  // Glass material with transparency
  const glassMaterial = new THREE.MeshPhysicalMaterial({
    color: '#f5f5f5',
    transparent: true,
    opacity: 0.3,
    roughness: 0.1,
    transmission: 0.9,
    thickness: 0.5,
  })

  return (
    <group>
      <OverheadCarcass width={width} height={height} depth={depth} />
      {/* Glass door */}
      <CabinetDoor
        width={w - 0.004}
        height={h - 0.004}
        depth={0.008} // Thinner glass
        position={[0, h/2, d/2]}
        hinge="left"
        material={glassMaterial}
      />
      {/* Interior shelf - visible through glass */}
      {Array.from({ length: shelfCount }).map((_, i) => (
        <mesh key={i} position={[0, h * ((i + 1) / (shelfCount + 1)), 0]}>
          <boxGeometry args={[w - 0.04, 0.018, d - 0.04]} />
          <meshStandardMaterial color="#e5e5e5" />
        </mesh>
      ))}
    </group>
  )
}

// 3. Open Shelf - no doors, exposed shelving
export function OpenShelf({ config, width, height = 600, depth = 350 }: OverheadModuleProps) {
  const shelfCount = config.interiorOptions?.shelfCount || 2
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS

  return (
    <group>
      <OverheadCarcass width={width} height={height} depth={depth} />
      {/* Visible shelves - no door */}
      {Array.from({ length: shelfCount }).map((_, i) => (
        <mesh key={i} position={[0, h * ((i + 1) / (shelfCount + 1)), 0]}>
          <boxGeometry args={[w - 0.04, 0.018, d - 0.04]} />
          <meshStandardMaterial color="#e5e5e5" />
        </mesh>
      ))}
    </group>
  )
}

// 4. Rangehood Space - open area for rangehood/exhaust
export function RangehoodSpace({ config, width, height = 600, depth = 350 }: OverheadModuleProps) {
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS

  return (
    <group>
      {/* Just the sides, no front/back - open space */}
      {/* Left side */}
      <mesh position={[-w/2 + 0.009, h/2, 0]}>
        <boxGeometry args={[0.018, h, d]} />
        <meshStandardMaterial color="#d4d4d4" />
      </mesh>
      {/* Right side */}
      <mesh position={[w/2 - 0.009, h/2, 0]}>
        <boxGeometry args={[0.018, h, d]} />
        <meshStandardMaterial color="#d4d4d4" />
      </mesh>
      {/* Top panel */}
      <mesh position={[0, h - 0.009, 0]}>
        <boxGeometry args={[w, 0.018, d]} />
        <meshStandardMaterial color="#d4d4d4" />
      </mesh>
      {/* Placeholder for rangehood */}
      <mesh position={[0, h * 0.3, d * 0.3]}>
        <boxGeometry args={[w * 0.7, h * 0.4, d * 0.4]} />
        <meshStandardMaterial color="#52525b" metalness={0.5} roughness={0.3} />
      </mesh>
    </group>
  )
}

// 5. Lift-Up Door - door that opens upward
export function LiftUpDoor({ config, width, height = 600, depth = 350 }: OverheadModuleProps) {
  const w = width * MM_TO_UNITS
  const h = height * MM_TO_UNITS
  const d = depth * MM_TO_UNITS
  const shelfCount = config.interiorOptions?.shelfCount || 1

  return (
    <group>
      <OverheadCarcass width={width} height={height} depth={depth} />
      {/* Lift-up door panel */}
      <LiftUpDoorPanel
        width={w - 0.004}
        height={h - 0.004}
        depth={0.018}
        position={[0, h/2, d/2]}
      />
      {/* Interior shelf */}
      {Array.from({ length: shelfCount }).map((_, i) => (
        <mesh key={i} position={[0, h * ((i + 1) / (shelfCount + 1)), 0]}>
          <boxGeometry args={[w - 0.04, 0.018, d - 0.04]} />
          <meshStandardMaterial color="#e5e5e5" />
        </mesh>
      ))}
    </group>
  )
}
```

Create `src/components/configurator/modules/ModuleFactory.tsx`:

```typescript
import type { ModuleConfig, ModuleType } from '@/types/configurator'
import {
  StandardBase, SinkBase, DrawerStack, PullOutPantry,
  CornerBase, ApplianceTower, OpenShelving
} from './BaseModule'
import {
  StandardOverhead, GlassDoor, OpenShelf,
  RangehoodSpace, LiftUpDoor
} from './OverheadModule'

interface ModuleFactoryProps {
  config: ModuleConfig
  width: number
  slotType: 'base' | 'overhead'
}

export function renderModule({ config, width, slotType }: ModuleFactoryProps) {
  const baseHeight = 800
  const overheadHeight = 600
  const height = slotType === 'base' ? baseHeight : overheadHeight
  const depth = slotType === 'base' ? 560 : 350

  switch (config.type) {
    // Base modules (7)
    case 'standard':
      return <StandardBase config={config} width={width} height={height} depth={depth} />
    case 'sink-base':
      return <SinkBase config={config} width={width} height={height} depth={depth} />
    case 'drawer-stack':
      return <DrawerStack config={config} width={width} height={height} depth={depth} />
    case 'pull-out-pantry':
      return <PullOutPantry config={config} width={width} height={2100} depth={depth} />
    case 'corner-base':
      return <CornerBase config={config} width={width} height={height} depth={depth} />
    case 'appliance-tower':
      return <ApplianceTower config={config} width={width} height={2100} depth={depth} />
    case 'open-shelving':
      return <OpenShelving config={config} width={width} height={height} depth={depth} />

    // Overhead modules (5)
    case 'standard-overhead':
      return <StandardOverhead config={config} width={width} height={height} depth={depth} />
    case 'glass-door':
      return <GlassDoor config={config} width={width} height={height} depth={depth} />
    case 'open-shelf':
      return <OpenShelf config={config} width={width} height={height} depth={depth} />
    case 'rangehood-space':
      return <RangehoodSpace config={config} width={width} height={height} depth={depth} />
    case 'lift-up-door':
      return <LiftUpDoor config={config} width={width} height={height} depth={depth} />

    default:
      console.warn(`Unknown module type: ${config.type}`)
      return null
  }
}
```

Update ModuleSlot to use renderModule for filled slots.
  </action>
  <verify>
Place each module type via ModulePicker.
All 7 base types render distinct 3D geometry.
All 5 overhead types render distinct 3D geometry.
Doors on applicable modules can be opened/closed (tap interaction).
Drawers slide out when tapped.
LiftUpDoor rotates upward when tapped.
GlassDoor shows transparent/frosted effect.
  </verify>
  <done>
All 12 module types render as 3D components with interactive doors, drawers, and lift-up panels.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create InteriorOptions bottom sheet for module customization</name>
  <files>
    src/components/wizard/InteriorOptions.tsx
  </files>
  <action>
Create `src/components/wizard/InteriorOptions.tsx`:

Per CONTEXT.md: Interior configuration flow is Claude's discretion.
Using nested bottom sheet that appears after module is placed.

Options per module type:
- Standard: shelf count (1-3)
- DrawerStack: drawer count (3-4), dividers (yes/no)
- OpenShelving: shelf count (1-4)
- Others: type-specific options

Also handle add-ons (LED strips, pull-out bins) per requirements.

```typescript
import Sheet from 'react-modal-sheet'
import { useCabinetStore } from '@/stores/useCabinetStore'
import type { ModuleConfig } from '@/types/configurator'
import { SliderControl } from '@/components/ui/slider-control'
import { Switch } from '@/components/ui/switch'
import { Label } from '@/components/ui/label'

// Add-ons available for any module
const ADDONS = [
  { id: 'led-strip', name: 'LED Strip', price: 85 },
  { id: 'pull-out-bin', name: 'Pull-out Bin', price: 120 },
  { id: 'drawer-divider', name: 'Drawer Dividers', price: 45 },
]

interface InteriorOptionsProps {
  isOpen: boolean
  slotId: string | null
  onClose: () => void
}

export function InteriorOptions({ isOpen, slotId, onClose }: InteriorOptionsProps) {
  const slots = useCabinetStore((state) => state.slots)
  const setModule = useCabinetStore((state) => state.setModule)

  const module = slotId ? slots.get(slotId) : null

  if (!module) return null

  const updateInterior = (key: string, value: any) => {
    if (!slotId) return
    setModule(slotId, {
      ...module,
      interiorOptions: {
        ...module.interiorOptions,
        [key]: value,
      },
    })
  }

  const toggleAddon = (addonId: string) => {
    if (!slotId) return
    const currentAddons = module.addons || []
    const newAddons = currentAddons.includes(addonId)
      ? currentAddons.filter((id) => id !== addonId)
      : [...currentAddons, addonId]

    setModule(slotId, { ...module, addons: newAddons })
  }

  // Render options based on module type
  const renderTypeOptions = () => {
    switch (module.type) {
      case 'standard':
      case 'open-shelving':
      case 'standard-overhead':
      case 'glass-door':
      case 'open-shelf':
      case 'lift-up-door':
        return (
          <div className="space-y-4">
            <h4 className="font-medium">Shelves</h4>
            <SliderControl
              label="Number of Shelves"
              value={module.interiorOptions?.shelfCount || 1}
              min={1}
              max={4}
              step={1}
              unit=""
              onChange={(v) => updateInterior('shelfCount', v)}
            />
          </div>
        )

      case 'drawer-stack':
        return (
          <div className="space-y-4">
            <h4 className="font-medium">Drawers</h4>
            <SliderControl
              label="Number of Drawers"
              value={module.interiorOptions?.drawerCount || 4}
              min={3}
              max={5}
              step={1}
              unit=""
              onChange={(v) => updateInterior('drawerCount', v)}
            />
            <div className="flex items-center justify-between">
              <Label>Drawer Dividers</Label>
              <Switch
                checked={module.interiorOptions?.hasDividers || false}
                onCheckedChange={(v) => updateInterior('hasDividers', v)}
              />
            </div>
          </div>
        )

      case 'pull-out-pantry':
        return (
          <div className="space-y-4">
            <h4 className="font-medium">Pull-out Baskets</h4>
            <SliderControl
              label="Number of Baskets"
              value={module.interiorOptions?.basketCount || 5}
              min={3}
              max={7}
              step={1}
              unit=""
              onChange={(v) => updateInterior('basketCount', v)}
            />
          </div>
        )

      case 'sink-base':
      case 'corner-base':
      case 'appliance-tower':
      case 'rangehood-space':
      default:
        return (
          <p className="text-sm text-zinc-500">
            No additional options for this module type.
          </p>
        )
    }
  }

  return (
    <Sheet
      isOpen={isOpen}
      onClose={onClose}
      snapPoints={[450, 0]}
      initialSnap={0}
    >
      <Sheet.Container>
        <Sheet.Header />
        <Sheet.Content>
          <div className="px-4 pb-8 space-y-6">
            <div>
              <h3 className="text-lg font-semibold">Interior Options</h3>
              <p className="text-sm text-zinc-500 capitalize">{module.type.replace(/-/g, ' ')}</p>
            </div>

            {renderTypeOptions()}

            {/* Add-ons section */}
            <div className="space-y-3">
              <h4 className="font-medium">Add-ons</h4>
              {ADDONS.map((addon) => (
                <div
                  key={addon.id}
                  className="flex items-center justify-between p-3 border rounded-lg"
                >
                  <div>
                    <p className="font-medium text-sm">{addon.name}</p>
                    <p className="text-xs text-zinc-500">+${addon.price}</p>
                  </div>
                  <Switch
                    checked={module.addons?.includes(addon.id) || false}
                    onCheckedChange={() => toggleAddon(addon.id)}
                  />
                </div>
              ))}
            </div>

            <button
              onClick={onClose}
              className="w-full py-3 bg-zinc-900 text-white rounded-lg font-medium"
            >
              Done
            </button>
          </div>
        </Sheet.Content>
      </Sheet.Container>
      <Sheet.Backdrop onTap={onClose} />
    </Sheet>
  )
}
```

Integrate InteriorOptions into StepLayout - show after module selection.
  </action>
  <verify>
Select a module with interior options (Standard, DrawerStack).
Interior options sheet opens automatically or via "Configure" button.
Changing shelf count updates store.
Adding add-ons updates store.
3D module updates to reflect new shelf count.
  </verify>
  <done>
InteriorOptions bottom sheet complete. Module interiors and add-ons configurable.
  </done>
</task>

</tasks>

<verification>
- All 12 module types render distinct 3D geometry
- Doors animate open/close on tap (CabinetDoor with Y-axis rotation)
- Drawers slide out on tap (CabinetDrawer with Z-axis translation)
- Lift-up doors rotate upward on tap (LiftUpDoorPanel with X-axis rotation)
- CabinetDoor animation is smooth (damp in useFrame)
- Interior options affect 3D render (shelf count visible)
- Add-ons can be toggled per module
- ModuleFactory correctly maps type to component
</verification>

<success_criteria>
- Complete 3D representation of all 12 module types
- Interactive doors, drawers, and lift-up panels with smooth animation
- Interior customization working
- Add-ons selectable
</success_criteria>

<output>
After completion, create `.planning/phases/04-3d-configurator-core/04-06-SUMMARY.md`
</output>
