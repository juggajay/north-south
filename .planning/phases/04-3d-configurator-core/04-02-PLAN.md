---
phase: 04-3d-configurator-core
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.js
  - convex/designs.js
  - convex/designVersions.js
  - src/lib/hooks/useAutoSave.ts
autonomous: true

must_haves:
  truths:
    - "Design versions table exists in Convex"
    - "Auto-save debounces at 1000ms"
    - "Version history can be retrieved for a design"
  artifacts:
    - path: "convex/schema.js"
      provides: "designVersions table schema"
      contains: "designVersions:"
    - path: "convex/designVersions.js"
      provides: "Version CRUD operations"
      exports: ["create", "list", "restore"]
    - path: "src/lib/hooks/useAutoSave.ts"
      provides: "Debounced auto-save hook"
      exports: ["useAutoSave"]
  key_links:
    - from: "src/lib/hooks/useAutoSave.ts"
      to: "convex/designs.js"
      via: "useMutation"
      pattern: "api\\.designs\\.update"
---

<objective>
Add version history support to Convex schema and create auto-save hook for continuous sync.

Purpose: Enables the "full version history" feature and continuous auto-save per CONTEXT.md decisions.
Output: Convex schema with designVersions table, version CRUD operations, and useAutoSave hook.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-3d-configurator-core/04-CONTEXT.md
@convex/schema.js
@convex/designs.js
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add designVersions table to Convex schema</name>
  <files>
    convex/schema.js
  </files>
  <action>
Add new `designVersions` table to convex/schema.js after the `designs` table:

```js
// ===================
// DESIGN VERSIONS (for history/restore)
// ===================
designVersions: defineTable({
  designId: v.id("designs"),
  version: v.number(), // Auto-incrementing per design
  config: v.any(), // Full config snapshot (dimensions, slots, finishes)
  thumbnail: v.optional(v.string()), // Optional screenshot storage ID
  label: v.optional(v.string()), // Optional user label ("Before adding pantry")
  createdAt: v.number(),
})
  .index("by_designId", ["designId"])
  .index("by_designId_version", ["designId", "version"]),
```

This allows:
- Listing all versions for a design (by_designId)
- Getting specific version by number (by_designId_version)
- Restoring any previous version

No changes to the existing designs table - versions are stored separately.
  </action>
  <verify>
Run `npx convex dev --once` to push schema (if Convex running) or check syntax.
Schema file has no JavaScript errors: `node --check convex/schema.js`
  </verify>
  <done>
designVersions table added to schema with appropriate indexes.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create Convex functions for version management</name>
  <files>
    convex/designVersions.js
  </files>
  <action>
Create `convex/designVersions.js` with:

**Mutations:**
1. `create` - Create new version snapshot
   - Args: designId, config, label (optional)
   - Get current max version number for design, increment
   - Insert new version record
   - Return version ID

2. `restore` - Restore design to a specific version
   - Args: designId, versionId
   - Get version config
   - Update designs.config with version config
   - Create a new version marking the restore point
   - Return updated design

**Queries:**
3. `list` - List all versions for a design
   - Args: designId, limit (default 20)
   - Return versions ordered by version number desc
   - Include version number, timestamp, label, config summary (dimensions only for list view)

4. `get` - Get specific version details
   - Args: versionId
   - Return full version record including config

Example implementation pattern:
```js
export const create = mutation({
  args: {
    designId: v.id("designs"),
    config: v.any(),
    label: v.optional(v.string()),
  },
  handler: async (ctx, { designId, config, label }) => {
    // Get current max version
    const versions = await ctx.db
      .query("designVersions")
      .withIndex("by_designId", (q) => q.eq("designId", designId))
      .order("desc")
      .first();

    const nextVersion = versions ? versions.version + 1 : 1;

    return await ctx.db.insert("designVersions", {
      designId,
      version: nextVersion,
      config,
      label,
      createdAt: Date.now(),
    });
  },
});
```
  </action>
  <verify>
Test mutations work by calling them from Convex dashboard or test script.
Verify version numbers auto-increment correctly.
Verify restore updates the design and creates restore-point version.
  </verify>
  <done>
Version management functions implemented: create, restore, list, get.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create useAutoSave hook with debounced Convex sync</name>
  <files>
    src/lib/hooks/useAutoSave.ts
  </files>
  <action>
Create `src/lib/hooks/useAutoSave.ts`:

Hook should:
1. Subscribe to useCabinetStore changes
2. Debounce saves at 1000ms (per RESEARCH.md recommendation)
3. Call designs.update mutation with current config
4. Call designVersions.create every N changes (e.g., every 10th auto-save) for version snapshots
5. Show "Saving..." indicator state
6. Handle errors gracefully (toast on failure, retry logic)

Implementation:
```typescript
import { useMutation } from 'convex/react'
import { api } from '../../convex/_generated/api'
import { useEffect, useState, useRef } from 'react'
import { useDebouncedCallback } from 'use-debounce'
import { useCabinetStore } from '@/stores/useCabinetStore'
import type { Id } from '../../convex/_generated/dataModel'

export function useAutoSave(designId: Id<"designs"> | null) {
  const [isSaving, setIsSaving] = useState(false)
  const [lastSaved, setLastSaved] = useState<Date | null>(null)
  const saveCount = useRef(0)

  const updateDesign = useMutation(api.designs.update)
  const createVersion = useMutation(api.designVersions.create)

  const cabinetState = useCabinetStore()

  const debouncedSave = useDebouncedCallback(
    async (config: any) => {
      if (!designId) return

      setIsSaving(true)
      try {
        await updateDesign({ id: designId, config })
        saveCount.current += 1

        // Create version snapshot every 10 saves
        if (saveCount.current % 10 === 0) {
          await createVersion({ designId, config })
        }

        setLastSaved(new Date())
      } catch (error) {
        console.error('Auto-save failed:', error)
        // Could add toast notification here
      } finally {
        setIsSaving(false)
      }
    },
    1000 // 1 second debounce
  )

  useEffect(() => {
    const config = {
      dimensions: cabinetState.dimensions,
      slots: Array.from(cabinetState.slots.entries()),
      finishes: cabinetState.finishes,
    }
    debouncedSave(config)
  }, [cabinetState.dimensions, cabinetState.slots, cabinetState.finishes])

  return { isSaving, lastSaved }
}
```

Also export a `SaveIndicator` component that shows subtle "Saving..." / "Saved" status.
  </action>
  <verify>
TypeScript compiles without errors.
Hook can be imported and used in a test component.
Verify debounce timing with console.log (should only fire 1 sec after last change).
  </verify>
  <done>
useAutoSave hook implemented with 1000ms debounce, version snapshots, and save status.
  </done>
</task>

</tasks>

<verification>
- Schema pushes to Convex without errors
- designVersions table has both indexes
- Version functions create/list/restore work
- useAutoSave debounces correctly at 1000ms
- Version snapshots created periodically
</verification>

<success_criteria>
- Full version history schema and operations in Convex
- Auto-save hook ready for configurator integration
- Debounce prevents excessive API calls
</success_criteria>

<output>
After completion, create `.planning/phases/04-3d-configurator-core/04-02-SUMMARY.md`
</output>
