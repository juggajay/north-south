---
phase: 04-3d-configurator-core
plan: 05
type: execute
wave: 3
depends_on: ["04-03", "04-04"]
files_modified:
  - src/components/configurator/ModuleSlot.tsx
  - src/components/configurator/SlotSystem.tsx
  - src/components/wizard/ModulePicker.tsx
  - src/components/wizard/StepLayout.tsx
autonomous: true

must_haves:
  truths:
    - "Empty slots visible in 3D view with tap targets"
    - "Tapping slot opens module picker bottom sheet"
    - "Selecting module places it in slot"
    - "Module picker shows all 12 module types"
  artifacts:
    - path: "src/components/configurator/ModuleSlot.tsx"
      provides: "Interactive slot in 3D view"
      exports: ["ModuleSlot"]
    - path: "src/components/configurator/SlotSystem.tsx"
      provides: "Slot layout calculator and renderer"
      exports: ["SlotSystem"]
    - path: "src/components/wizard/ModulePicker.tsx"
      provides: "Bottom sheet module selection"
      exports: ["ModulePicker"]
    - path: "src/components/wizard/StepLayout.tsx"
      provides: "Step 2 layout controls"
      exports: ["StepLayout"]
  key_links:
    - from: "src/components/configurator/ModuleSlot.tsx"
      to: "src/stores/useCabinetStore.ts"
      via: "setModule action"
      pattern: "setModule\\("
    - from: "src/components/wizard/ModulePicker.tsx"
      to: "src/stores/useCabinetStore.ts"
      via: "setModule on selection"
      pattern: "setModule\\("
---

<objective>
Implement slot-based module placement system with bottom sheet picker (Step 2: Layout).

Purpose: Core configurator interaction - users tap slots in 3D view and select modules from a visual picker.
Output: SlotSystem calculating positions, ModuleSlot with tap handling, ModulePicker bottom sheet, StepLayout component.
</objective>

<execution_context>
@./.claude/get-shit-done/workflows/execute-plan.md
@./.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-3d-configurator-core/04-CONTEXT.md
@.planning/phases/04-3d-configurator-core/04-RESEARCH.md
@src/stores/useCabinetStore.ts
@src/types/configurator.ts
@src/components/configurator/CabinetModel.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create SlotSystem that calculates slot positions</name>
  <files>
    src/components/configurator/SlotSystem.tsx
  </files>
  <action>
Create `src/components/configurator/SlotSystem.tsx`:

The slot system calculates available slots based on cabinet dimensions:
- Base cabinets: Floor level, divided into slots based on width
- Overhead cabinets: Upper area, divided into slots

Slot calculation logic:
- Standard module widths: 300, 400, 450, 500, 600, 750, 900mm
- Calculate how many slots fit in total width
- Position slots left-to-right, centered in cabinet
- Generate unique slot IDs (e.g., "base-1", "base-2", "overhead-1")

```typescript
import { useFrame } from '@react-three/fiber'
import { useRef, useMemo, useState, useEffect } from 'react'
import { useCabinetStore } from '@/stores/useCabinetStore'
import { ModuleSlot } from './ModuleSlot'

const MM_TO_UNITS = 0.001
const DEFAULT_SLOT_WIDTH = 600 // mm

interface SlotPosition {
  id: string
  type: 'base' | 'overhead'
  x: number // Center X position in scene units
  y: number // Y position
  z: number // Z position (depth center)
  width: number // Slot width in mm
}

function calculateSlots(dimensions: { width: number; height: number; depth: number }): SlotPosition[] {
  const slots: SlotPosition[] = []
  const cabinetWidth = dimensions.width
  const cabinetDepth = dimensions.depth

  // Calculate number of base slots (simple division for now)
  const numBaseSlots = Math.floor(cabinetWidth / DEFAULT_SLOT_WIDTH)
  const baseSlotWidth = cabinetWidth / numBaseSlots

  // Base cabinet slots
  for (let i = 0; i < numBaseSlots; i++) {
    const xOffset = (i - (numBaseSlots - 1) / 2) * (baseSlotWidth * MM_TO_UNITS)
    slots.push({
      id: `base-${i + 1}`,
      type: 'base',
      x: xOffset,
      y: 0.4, // Base cabinet height center (800mm / 2)
      z: 0,
      width: baseSlotWidth,
    })
  }

  // Overhead cabinet slots (same number as base for symmetry)
  for (let i = 0; i < numBaseSlots; i++) {
    const xOffset = (i - (numBaseSlots - 1) / 2) * (baseSlotWidth * MM_TO_UNITS)
    slots.push({
      id: `overhead-${i + 1}`,
      type: 'overhead',
      x: xOffset,
      y: 1.7, // Overhead height center
      z: cabinetDepth * MM_TO_UNITS * -0.3, // Slightly forward
      width: baseSlotWidth,
    })
  }

  return slots
}

interface SlotSystemProps {
  onSlotTap: (slotId: string) => void
}

export function SlotSystem({ onSlotTap }: SlotSystemProps) {
  const [slots, setSlots] = useState<SlotPosition[]>([])
  const dimensions = useCabinetStore((state) => state.dimensions)
  const moduleConfigs = useCabinetStore((state) => state.slots)

  // Recalculate slots when dimensions change
  useEffect(() => {
    setSlots(calculateSlots(dimensions))
  }, [dimensions])

  return (
    <group>
      {slots.map((slot) => (
        <ModuleSlot
          key={slot.id}
          slotId={slot.id}
          position={[slot.x, slot.y, slot.z]}
          width={slot.width}
          type={slot.type}
          module={moduleConfigs.get(slot.id) || null}
          onTap={() => onSlotTap(slot.id)}
        />
      ))}
    </group>
  )
}
```
  </action>
  <verify>
Import SlotSystem into CabinetModel.
Slots appear in 3D view at calculated positions.
Changing dimensions updates slot count/positions.
  </verify>
  <done>
SlotSystem calculates and renders slot positions based on cabinet dimensions.
  </done>
</task>

<task type="auto">
  <name>Task 2: Create ModuleSlot with empty state and tap handling</name>
  <files>
    src/components/configurator/ModuleSlot.tsx
  </files>
  <action>
Create `src/components/configurator/ModuleSlot.tsx`:

Per CONTEXT.md: Empty slot appearance is Claude's discretion. Using wireframe/dashed approach for clear boundaries.

ModuleSlot component:
- When empty: Shows wireframe placeholder with dashed edges
- When filled: Renders module geometry (placeholder for now, actual models in Plan 06)
- Tap handler to open module picker
- Visual feedback on hover/tap (color change, subtle scale)

```typescript
import { useRef, useState } from 'react'
import { useFrame } from '@react-three/fiber'
import { Edges, Box, Html } from '@react-three/drei'
import * as THREE from 'three'
import type { ModuleConfig } from '@/types/configurator'

const MM_TO_UNITS = 0.001

interface ModuleSlotProps {
  slotId: string
  position: [number, number, number]
  width: number // in mm
  type: 'base' | 'overhead'
  module: ModuleConfig | null
  onTap: () => void
}

export function ModuleSlot({ slotId, position, width, type, module, onTap }: ModuleSlotProps) {
  const meshRef = useRef<THREE.Mesh>(null)
  const [hovered, setHovered] = useState(false)

  // Slot dimensions
  const slotWidth = width * MM_TO_UNITS
  const slotHeight = type === 'base' ? 0.8 : 0.6 // 800mm base, 600mm overhead
  const slotDepth = 0.56 // 560mm standard depth

  // Handle pointer events
  const handlePointerOver = () => {
    setHovered(true)
    document.body.style.cursor = 'pointer'
  }

  const handlePointerOut = () => {
    setHovered(false)
    document.body.style.cursor = 'default'
  }

  const handleClick = (event: THREE.Event) => {
    event.stopPropagation()
    onTap()
  }

  if (module) {
    // Render filled module (placeholder - actual models in Plan 06)
    return (
      <mesh
        ref={meshRef}
        position={position}
        onClick={handleClick}
        onPointerOver={handlePointerOver}
        onPointerOut={handlePointerOut}
      >
        <boxGeometry args={[slotWidth * 0.95, slotHeight * 0.95, slotDepth * 0.95]} />
        <meshStandardMaterial
          color={hovered ? '#525252' : '#737373'}
        />
        <Edges color="#262626" lineWidth={1} />
        {/* Module label */}
        <Html
          position={[0, slotHeight / 2 + 0.05, slotDepth / 2 + 0.01]}
          center
          style={{ pointerEvents: 'none' }}
        >
          <div className="px-2 py-1 bg-white/90 rounded text-xs font-medium whitespace-nowrap">
            {module.type}
          </div>
        </Html>
      </mesh>
    )
  }

  // Render empty slot placeholder
  return (
    <mesh
      ref={meshRef}
      position={position}
      onClick={handleClick}
      onPointerOver={handlePointerOver}
      onPointerOut={handlePointerOut}
    >
      <boxGeometry args={[slotWidth * 0.95, slotHeight * 0.95, slotDepth * 0.95]} />
      <meshBasicMaterial
        color={hovered ? '#a1a1aa' : '#e4e4e7'}
        transparent
        opacity={hovered ? 0.4 : 0.2}
        wireframe={false}
      />
      <Edges
        color={hovered ? '#52525b' : '#a1a1aa'}
        lineWidth={1}
      />
      {/* Plus icon for empty slot */}
      <Html center style={{ pointerEvents: 'none' }}>
        <div className={`text-2xl ${hovered ? 'text-zinc-600' : 'text-zinc-400'}`}>
          +
        </div>
      </Html>
    </mesh>
  )
}
```
  </action>
  <verify>
Render slots in scene.
Empty slots show wireframe with + icon.
Hovering changes color and cursor.
Tapping triggers onTap callback.
Filled slots show solid geometry with label.
  </verify>
  <done>
ModuleSlot renders empty/filled states with tap interaction and visual feedback.
  </done>
</task>

<task type="auto">
  <name>Task 3: Create ModulePicker bottom sheet and StepLayout</name>
  <files>
    src/components/wizard/ModulePicker.tsx
    src/components/wizard/StepLayout.tsx
  </files>
  <action>
Create `src/components/wizard/ModulePicker.tsx`:

Per CONTEXT.md: Module picker UI is Claude's discretion. Using bottom sheet with grid of module thumbnails.

```typescript
import Sheet from 'react-modal-sheet'
import { useCabinetStore } from '@/stores/useCabinetStore'
import type { ModuleType } from '@/types/configurator'

// Module type definitions with display info
const BASE_MODULES: { type: ModuleType; name: string; description: string }[] = [
  { type: 'standard', name: 'Standard Cabinet', description: 'Shelf and door' },
  { type: 'sink-base', name: 'Sink Base', description: 'Open for plumbing' },
  { type: 'drawer-stack', name: 'Drawer Stack', description: '3-4 drawers' },
  { type: 'pull-out-pantry', name: 'Pull-out Pantry', description: 'Tall pull-out' },
  { type: 'corner-base', name: 'Corner Cabinet', description: 'L-shaped corner' },
  { type: 'appliance-tower', name: 'Appliance Tower', description: 'Oven/microwave' },
  { type: 'open-shelving', name: 'Open Shelving', description: 'No doors' },
]

const OVERHEAD_MODULES: { type: ModuleType; name: string; description: string }[] = [
  { type: 'standard-overhead', name: 'Standard Overhead', description: 'Single door' },
  { type: 'glass-door', name: 'Glass Door', description: 'Display cabinet' },
  { type: 'open-shelf', name: 'Open Shelf', description: 'No doors' },
  { type: 'rangehood-space', name: 'Rangehood Space', description: 'For rangehood' },
  { type: 'lift-up-door', name: 'Lift-up Door', description: 'Lifts upward' },
]

interface ModulePickerProps {
  isOpen: boolean
  slotId: string | null
  slotType: 'base' | 'overhead' | null
  onClose: () => void
}

export function ModulePicker({ isOpen, slotId, slotType, onClose }: ModulePickerProps) {
  const setModule = useCabinetStore((state) => state.setModule)

  const modules = slotType === 'base' ? BASE_MODULES : OVERHEAD_MODULES

  const handleSelect = (moduleType: ModuleType) => {
    if (!slotId) return

    setModule(slotId, {
      type: moduleType,
      width: 600, // Default width
      interiorOptions: {},
      addons: [],
    })

    onClose()
  }

  const handleRemove = () => {
    if (!slotId) return
    useCabinetStore.getState().removeModule(slotId)
    onClose()
  }

  return (
    <Sheet
      isOpen={isOpen}
      onClose={onClose}
      snapPoints={[500, 300, 0]}
      initialSnap={0}
    >
      <Sheet.Container>
        <Sheet.Header />
        <Sheet.Content>
          <div className="px-4 pb-8">
            <h3 className="text-lg font-semibold mb-4">
              Select {slotType === 'base' ? 'Base' : 'Overhead'} Module
            </h3>

            <div className="grid grid-cols-2 gap-3">
              {modules.map((module) => (
                <button
                  key={module.type}
                  onClick={() => handleSelect(module.type)}
                  className="p-4 border rounded-lg text-left hover:border-zinc-400 hover:bg-zinc-50 active:bg-zinc-100"
                >
                  {/* Placeholder for real product photos per CONTEXT.md */}
                  <div className="w-full h-20 bg-zinc-200 rounded mb-2 flex items-center justify-center text-zinc-400">
                    Photo
                  </div>
                  <p className="font-medium text-sm">{module.name}</p>
                  <p className="text-xs text-zinc-500">{module.description}</p>
                </button>
              ))}
            </div>

            {/* Remove option if slot is filled */}
            <button
              onClick={handleRemove}
              className="w-full mt-4 py-3 text-red-600 text-sm font-medium"
            >
              Remove Module
            </button>
          </div>
        </Sheet.Content>
      </Sheet.Container>
      <Sheet.Backdrop onTap={onClose} />
    </Sheet>
  )
}
```

Create `src/components/wizard/StepLayout.tsx`:

```typescript
import { useState } from 'react'
import { useCabinetStore } from '@/stores/useCabinetStore'
import { ModulePicker } from './ModulePicker'

interface StepLayoutProps {
  onSlotTap: (slotId: string, slotType: 'base' | 'overhead') => void
  selectedSlot: { id: string; type: 'base' | 'overhead' } | null
  onClosePicker: () => void
}

export function StepLayout({ onSlotTap, selectedSlot, onClosePicker }: StepLayoutProps) {
  const slots = useCabinetStore((state) => state.slots)

  const filledCount = slots.size
  const isEmpty = filledCount === 0

  return (
    <div className="p-4">
      <div className="mb-4">
        <h2 className="text-lg font-semibold text-zinc-900">Configure Layout</h2>
        <p className="text-sm text-zinc-500">
          Tap slots in the 3D view to add modules.
        </p>
      </div>

      {/* Summary */}
      <div className="p-4 bg-zinc-100 rounded-lg">
        <p className="text-sm text-zinc-600">
          {isEmpty
            ? 'No modules added yet. Tap a slot above to get started.'
            : `${filledCount} module${filledCount !== 1 ? 's' : ''} configured`}
        </p>
      </div>

      {/* List of configured modules */}
      {filledCount > 0 && (
        <div className="mt-4 space-y-2">
          <h4 className="text-sm font-medium text-zinc-700">Configured Modules</h4>
          {Array.from(slots.entries()).map(([slotId, config]) => (
            <div
              key={slotId}
              className="flex items-center justify-between p-3 bg-white border rounded-lg"
            >
              <div>
                <p className="text-sm font-medium">{config.type}</p>
                <p className="text-xs text-zinc-500">{slotId}</p>
              </div>
              <button
                onClick={() => onSlotTap(slotId, slotId.startsWith('base') ? 'base' : 'overhead')}
                className="text-sm text-zinc-600 hover:text-zinc-900"
              >
                Edit
              </button>
            </div>
          ))}
        </div>
      )}

      {/* Module picker sheet */}
      <ModulePicker
        isOpen={selectedSlot !== null}
        slotId={selectedSlot?.id || null}
        slotType={selectedSlot?.type || null}
        onClose={onClosePicker}
      />
    </div>
  )
}
```

Update WizardShell to integrate StepLayout and pass slot tap handlers.
  </action>
  <verify>
Navigate to Step 2 (Layout).
Slots visible in 3D view.
Tap slot opens ModulePicker bottom sheet.
Select module - it appears in slot.
Module picker shows correct types for base vs overhead.
Configured modules listed in StepLayout.
  </verify>
  <done>
ModulePicker bottom sheet and StepLayout component complete. Slot selection flow working.
  </done>
</task>

</tasks>

<verification>
- Slots appear at correct positions based on dimensions
- Empty slots show wireframe with + icon
- Tap on slot opens bottom sheet
- All 12 module types available (7 base + 5 overhead)
- Selecting module places it in slot
- Filled slots show module type label
- Module list in StepLayout updates
- Validation allows Next when at least one module placed
</verification>

<success_criteria>
- Slot-based module placement fully functional
- Visual feedback on tap/hover
- Bottom sheet picker with all module types
- Step 2 (Layout) complete
</success_criteria>

<output>
After completion, create `.planning/phases/04-3d-configurator-core/04-05-SUMMARY.md`
</output>
